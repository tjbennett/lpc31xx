Bottom: 274820e36e012ba511c16096bc824df4c663d1ed
Top:    9bd3c3f5df66b9bffcdf10a227ece36912d6dc69
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-15 19:35:45 -0400

mmc dma 


---

diff --git a/arch/arm/mach-lpc31xx/include/mach/hardware.h b/arch/arm/mach-lpc31xx/include/mach/hardware.h
index ba9e22b..5b0eca1 100644
--- a/arch/arm/mach-lpc31xx/include/mach/hardware.h
+++ b/arch/arm/mach-lpc31xx/include/mach/hardware.h
@@ -47,7 +47,7 @@
 /*
  * This __REG() version gives the same results as the one above,  except
  * that we are fooling gcc somehow so it generates far better and smaller
- * assembly code for access to contigous registers.  
+ * assembly code for access to contiguous registers.
  */
 #include <asm/types.h>
 typedef struct { volatile u32 offset[4096]; } __regbase;
diff --git a/arch/arm/mach-lpc31xx/include/mach/registers.h b/arch/arm/mach-lpc31xx/include/mach/registers.h
index 0ec045a..a0d82c6 100644
--- a/arch/arm/mach-lpc31xx/include/mach/registers.h
+++ b/arch/arm/mach-lpc31xx/include/mach/registers.h
@@ -427,6 +427,7 @@
 #define MPMC_SDRAMC_RASCAS_RAS2        _SBF(0,2)
 #define MPMC_SDRAMC_RASCAS_RAS3        _SBF(0,3)
 
+#if 0
 /***********************************************************************
  * SD/MMC MCI register definitions
  **********************************************************************/
@@ -520,7 +521,7 @@
 /* Status register defines */
 #define SDMMC_GET_FCNT(x)       (((x)>>17) & 0x1FF)
 #define SDMMC_FIFO_SZ           32
-
+#endif
 
 /***********************************************************************
  * NAND Controller register definitions
diff --git a/drivers/mmc/host/lpc31xx_mmc.c b/drivers/mmc/host/lpc31xx_mmc.c
index e4190c0..adefd33 100644
--- a/drivers/mmc/host/lpc31xx_mmc.c
+++ b/drivers/mmc/host/lpc31xx_mmc.c
@@ -49,8 +49,8 @@
 /* for time being use arch specific DMA framework instead of generic framework */
 #include <mach/dma.h>
 
-#define USE_DMA
-#define BURST_DMA
+//#define USE_DMA
+//#define BURST_DMA
 
 #define LPC313x_MCI_DATA_ERROR_FLAGS	(SDMMC_INT_DTO | SDMMC_INT_DCRC | SDMMC_INT_HTO | SDMMC_INT_SBE | SDMMC_INT_EBE)
 #define LPC313x_MCI_CMD_ERROR_FLAGS	(SDMMC_INT_RTO | SDMMC_INT_RCRC | SDMMC_INT_RESP_ERR | SDMMC_INT_HLE)
@@ -139,6 +139,21 @@ struct lpc313x_mci_slot {
 	struct timer_list	detect_timer;
 };
 
+/* Register access macros */
+//#define mci_readl(reg) __raw_readl(&SDMMC_##reg)
+//#define mci_writel(reg,value) __raw_writel((value),&SDMMC_##reg)
+
+static inline uint32_t mci_readl(struct lpc313x_mci *host, uint32_t reg)
+{
+	return __raw_readl(host->regs + reg);
+}
+
+static inline void mci_writel(struct lpc313x_mci *host, uint32_t reg, uint32_t value)
+{
+	__raw_writel(value, host->regs + reg);
+}
+
+
 #define lpc313x_mci_test_and_clear_pending(host, event)		\
 	test_and_clear_bit(event, &host->pending_events)
 #define lpc313x_mci_set_completed(host, event)			\
@@ -296,7 +311,7 @@ static void lpc313x_mci_set_timeout(struct lpc313x_mci *host,
 	/* the standard response timeout value (Ncr) is 64 clocks.
 	 * Let give 4 additional clocks for response.
 	 */
-	mci_writel(TMOUT, /*0xffffffff); */ (timeout << 8) | (70));
+	mci_writel(host, SDMMC_TMOUT, /*0xffffffff); */ (timeout << 8) | (70));
 }
 
 static u32 lpc313x_mci_prepare_command(struct mmc_host *mmc,
@@ -348,11 +363,11 @@ static void lpc313x_mci_start_command(struct lpc313x_mci *host,
 	dev_vdbg(&host->pdev->dev,
 			"start cmd:%d ARGR=0x%08x CMDR=0x%08x\n",
 			cmd->opcode, cmd->arg, cmd_flags);
-	mci_writel(CMDARG, cmd->arg); // write to CMDARG register
-	mci_writel(CMD, cmd_flags | SDMMC_CMD_START); // write to CMD register
+	mci_writel(host, SDMMC_CMDARG, cmd->arg); // write to CMDARG register
+	mci_writel(host, SDMMC_CMD, cmd_flags | SDMMC_CMD_START); // write to CMD register
 
 	/* wait until CIU accepts the command */
-	while (--tmo && (mci_readl(CMD) & SDMMC_CMD_START))
+	while (--tmo && (mci_readl(host, SDMMC_CMD) & SDMMC_CMD_START))
 		cpu_relax();
 }
 
@@ -543,15 +558,15 @@ static void lpc313x_mci_submit_data(struct lpc313x_mci *host, struct mmc_data *d
 			host->dir_status = LPC313x_MCI_SEND_STATUS;
 
 		//SDMMC_INTMASK |= (SDMMC_INT_RXDR | SDMMC_INT_TXDR);
-		SDMMC_CTRL &= ~SDMMC_CTRL_DMA_ENABLE; // enable dma
+		mci_writel(host, SDMMC_CTRL, mci_readl(host, SDMMC_CTRL) & ~SDMMC_CTRL_DMA_ENABLE); // enable dma
 	}
 
 }
 
-#define mci_send_cmd(cmd,arg) {	\
-    SDMMC_CMDARG = arg;		\
-    SDMMC_CMD = SDMMC_CMD_START | cmd;\
-    while (SDMMC_CMD & SDMMC_CMD_START); \
+#define mci_send_cmd(host, cmd, arg) { \
+    mci_writel(host, SDMMC_CMDARG, arg); \
+    mci_writel(host, SDMMC_CMD, SDMMC_CMD_START | cmd); \
+    while (mci_readl(host, SDMMC_CMD) & SDMMC_CMD_START); \
 }
 
 void lpc313x_mci_setup_bus(struct lpc313x_mci_slot *slot)
@@ -568,24 +583,24 @@ void lpc313x_mci_setup_bus(struct lpc313x_mci_slot *slot)
 		/* store the actual clock for calculations */
 		slot->clock = (host->bus_hz / div) >> 1;
 		/* disable clock */
-		mci_writel(CLKENA, 0);
-		mci_writel(CLKSRC,0);
+		mci_writel(host, SDMMC_CLKENA, 0);
+		mci_writel(host, SDMMC_CLKSRC,0);
 		/* inform CIU */
-		mci_send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
+		mci_send_cmd(host, SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
 		/* set clock to desired speed */
-		mci_writel(CLKDIV, div);
+		mci_writel(host, SDMMC_CLKDIV, div);
 		/* inform CIU */
-		mci_send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
+		mci_send_cmd(host, SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
 		/* enable clock */
-		mci_writel(CLKENA, SDMMC_CLKEN_ENABLE);
+		mci_writel(host, SDMMC_CLKENA, SDMMC_CLKEN_ENABLE);
 		/* inform CIU */
-		 mci_send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
+		 mci_send_cmd(host, SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
 
 		host->current_speed = slot->clock;
 	}
 
 	/* Set the current slot bus width */
-	mci_writel(CTYPE, slot->ctype);
+	mci_writel(host, SDMMC_CTYPE, slot->ctype);
 }
 
 static void lpc313x_mci_select_slot(struct lpc313x_mci_slot *slot, int enable)
@@ -638,8 +653,8 @@ static void lpc313x_mci_start_request(struct lpc313x_mci *host,
 	data = mrq->data;
 	if (data) {
 		lpc313x_mci_set_timeout(host, slot, data);
-		mci_writel(BYTCNT,data->blksz*data->blocks);
-		mci_writel(BLKSIZ,data->blksz);
+		mci_writel(host, SDMMC_BYTCNT,data->blksz*data->blocks);
+		mci_writel(host, SDMMC_BLKSIZ,data->blksz);
 	}
 
 	cmd = mrq->cmd;
@@ -760,17 +775,19 @@ static int lpc313x_mci_get_cd(struct lpc313x_mci_slot *slot)
 	return present;
 }
 
-static void lpc313x_mci_enable_sdio_irq(struct mmc_host *host, int enable)
+static void lpc313x_mci_enable_sdio_irq(struct mmc_host *mmc, int enable)
 {
+	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
+	struct lpc313x_mci	*host = slot->host;
 	unsigned int reg;
 
 	if (enable) {
-		reg = mci_readl(INTMASK) | SDMMC_INT_SDIO;
-		mci_writel(INTMASK, reg);
+		reg = mci_readl(host, SDMMC_INTMASK) | SDMMC_INT_SDIO;
+		mci_writel(host, SDMMC_INTMASK, reg);
 	}
 	else {
-		reg = mci_readl(INTMASK) & ~SDMMC_INT_SDIO;
-		mci_writel(INTMASK, reg);
+		reg = mci_readl(host, SDMMC_INTMASK) & ~SDMMC_INT_SDIO;
+		mci_writel(host, SDMMC_INTMASK, reg);
 	}
 }
 
@@ -830,12 +847,12 @@ static void lpc313x_mci_command_complete(struct lpc313x_mci *host,
 		 * core/sd.c expect those bits be in resp[0]. Hence
 		 * reverse the response word order.
 		 */
-		cmd->resp[3] = mci_readl(RESP0);
-		cmd->resp[2] = mci_readl(RESP1);
-		cmd->resp[1] = mci_readl(RESP2);
-		cmd->resp[0] = mci_readl(RESP3);
+		cmd->resp[3] = mci_readl(host, SDMMC_RESP0);
+		cmd->resp[2] = mci_readl(host, SDMMC_RESP1);
+		cmd->resp[1] = mci_readl(host, SDMMC_RESP2);
+		cmd->resp[0] = mci_readl(host, SDMMC_RESP3);
 	    } else {
-	        cmd->resp[0] = mci_readl(RESP0);
+	        cmd->resp[0] = mci_readl(host, SDMMC_RESP0);
 		cmd->resp[1] = 0;
 		cmd->resp[2] = 0;
 		cmd->resp[3] = 0;
@@ -993,7 +1010,7 @@ unlock:
 
 
 
-inline static void lpc313x_mci_push_data(void *buf,int cnt)
+inline static void lpc313x_mci_push_data(struct lpc313x_mci *host, void *buf, int cnt)
 {
     u32* pData = (u32*)buf;
 
@@ -1002,12 +1019,12 @@ inline static void lpc313x_mci_push_data(void *buf,int cnt)
 
     cnt = cnt >> 2;
     while (cnt > 0) {
-        SDMMC_DATA = *pData++ ;
+        mci_writel(host, SDMMC_DATA, *pData++);
         cnt--;
     }
 }
 
-inline static void lpc313x_mci_pull_data(void *buf,int cnt)
+inline static void lpc313x_mci_pull_data(struct lpc313x_mci *host, void *buf,int cnt)
 {
     u32* pData = (u32*)buf;
 
@@ -1015,7 +1032,7 @@ inline static void lpc313x_mci_pull_data(void *buf,int cnt)
 	    printk("error not align 4\n");
     cnt = cnt >> 2;
     while (cnt > 0) {
-        *pData++ = SDMMC_DATA;
+        *pData++ = mci_readl(host, SDMMC_DATA);
         cnt--;
     }
 }
@@ -1030,11 +1047,11 @@ static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
 	unsigned int		nbytes = 0,len,old_len,count =0;
 
 	do {
-		len = SDMMC_GET_FCNT(mci_readl(STATUS)) << 2;
+		len = SDMMC_GET_FCNT(mci_readl(host, SDMMC_STATUS)) << 2;
 		if(count == 0)
 			old_len = len;
 		if (likely(offset + len <= sg->length)) {
-			lpc313x_mci_pull_data((void *)(buf + offset),len);
+			lpc313x_mci_pull_data(host, (void *)(buf + offset),len);
 
 			offset += len;
 			nbytes += len;
@@ -1049,7 +1066,7 @@ static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
 			}
 		} else {
 			unsigned int remaining = sg->length - offset;
-			lpc313x_mci_pull_data((void *)(buf + offset),remaining);
+			lpc313x_mci_pull_data(host, (void *)(buf + offset),remaining);
 			nbytes += remaining;
 
 			flush_dcache_page(sg_page(sg));
@@ -1058,12 +1075,12 @@ static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
 				goto done;
 			offset = len - remaining;
 			buf = sg_virt(sg);
-			lpc313x_mci_pull_data(buf,offset);
+			lpc313x_mci_pull_data(host, buf,offset);
 			nbytes += offset;
 		}
 
-		status = mci_readl(MINTSTS);
-		mci_writel(RINTSTS,SDMMC_INT_RXDR); // clear RXDR interrupt
+		status = mci_readl(host, SDMMC_MINTSTS);
+		mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_RXDR); // clear RXDR interrupt
 		if (status & LPC313x_MCI_DATA_ERROR_FLAGS) {
 			host->data_status = status;
 			data->bytes_xfered += nbytes;
@@ -1074,7 +1091,7 @@ static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
 		}
 		count ++;
 	} while (status & SDMMC_INT_RXDR); // if the RXDR is ready let read again
-	len = SDMMC_GET_FCNT(mci_readl(STATUS));
+	len = SDMMC_GET_FCNT(mci_readl(host, SDMMC_STATUS));
 	host->pio_offset = offset;
 	data->bytes_xfered += nbytes;
 	return;
@@ -1096,9 +1113,9 @@ static void lpc313x_mci_write_data_pio(struct lpc313x_mci *host)
 
 	do {
 
-		len = SDMMC_FIFO_SZ - (SDMMC_GET_FCNT(mci_readl(STATUS)) << 2);
+		len = SDMMC_FIFO_SZ - (SDMMC_GET_FCNT(mci_readl(host, SDMMC_STATUS)) << 2);
 		if (likely(offset + len <= sg->length)) {
-			lpc313x_mci_push_data((void *)(buf + offset),len);
+			lpc313x_mci_push_data(host, (void *)(buf + offset),len);
 
 			offset += len;
 			nbytes += len;
@@ -1113,7 +1130,7 @@ static void lpc313x_mci_write_data_pio(struct lpc313x_mci *host)
 		} else {
 			unsigned int remaining = sg->length - offset;
 
-			lpc313x_mci_push_data((void *)(buf + offset), remaining);
+			lpc313x_mci_push_data(host, (void *)(buf + offset), remaining);
 			nbytes += remaining;
 
 			host->sg = sg = sg_next(sg);
@@ -1123,12 +1140,12 @@ static void lpc313x_mci_write_data_pio(struct lpc313x_mci *host)
 
 			offset = len - remaining;
 			buf = sg_virt(sg);
-			lpc313x_mci_push_data((void *)buf, offset);
+			lpc313x_mci_push_data(host, (void *)buf, offset);
 			nbytes += offset;
 		}
 
-		status = mci_readl(MINTSTS);
-		mci_writel(RINTSTS,SDMMC_INT_TXDR); // clear RXDR interrupt
+		status = mci_readl(host, SDMMC_MINTSTS);
+		mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_TXDR); // clear RXDR interrupt
 		if (status & LPC313x_MCI_DATA_ERROR_FLAGS) {
 			host->data_status = status;
 			data->bytes_xfered += nbytes;
@@ -1168,12 +1185,12 @@ static irqreturn_t lpc313x_mci_interrupt(int irq, void *dev_id)
 
 	spin_lock(&host->lock);
 	do {
-		status = mci_readl(RINTSTS);
-		pending = mci_readl(MINTSTS);// read only mask reg
+		status = mci_readl(host, SDMMC_RINTSTS);
+		pending = mci_readl(host, SDMMC_MINTSTS);// read only mask reg
 		if (!pending)
 			break;
 		if(pending & LPC313x_MCI_CMD_ERROR_FLAGS) {
-		    mci_writel(RINTSTS,LPC313x_MCI_CMD_ERROR_FLAGS);  //  clear interrupt
+		    mci_writel(host, SDMMC_RINTSTS,LPC313x_MCI_CMD_ERROR_FLAGS);  //  clear interrupt
 		    host->cmd_status = status;
 		    smp_wmb();
 		    lpc313x_mci_set_pending(host, EVENT_CMD_COMPLETE);
@@ -1181,7 +1198,7 @@ static irqreturn_t lpc313x_mci_interrupt(int irq, void *dev_id)
 		}
 
 		if (pending & LPC313x_MCI_DATA_ERROR_FLAGS) { // if there is an error, let report DATA_ERROR
-			mci_writel(RINTSTS,LPC313x_MCI_DATA_ERROR_FLAGS);  // clear interrupt
+			mci_writel(host, SDMMC_RINTSTS,LPC313x_MCI_DATA_ERROR_FLAGS);  // clear interrupt
 			host->data_status = status;
 			smp_wmb();
 			lpc313x_mci_set_pending(host, EVENT_DATA_ERROR);
@@ -1190,7 +1207,7 @@ static irqreturn_t lpc313x_mci_interrupt(int irq, void *dev_id)
 
 
 		if(pending & SDMMC_INT_DATA_OVER) {
-		    mci_writel(RINTSTS,SDMMC_INT_DATA_OVER);  // clear interrupt
+		    mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_DATA_OVER);  // clear interrupt
 		    if (!host->data_status)
 			host->data_status = status;
 		    smp_wmb();
@@ -1203,25 +1220,25 @@ static irqreturn_t lpc313x_mci_interrupt(int irq, void *dev_id)
 		}
 
 		if (pending & SDMMC_INT_RXDR) {
-		    mci_writel(RINTSTS,SDMMC_INT_RXDR);  //  clear interrupt
+		    mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_RXDR);  //  clear interrupt
 		    if(host->sg)
 			    lpc313x_mci_read_data_pio(host);
 		}
 
 		if (pending & SDMMC_INT_TXDR) {
-		    mci_writel(RINTSTS,SDMMC_INT_TXDR);  //  clear interrupt
+		    mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_TXDR);  //  clear interrupt
 		    if(host->sg) {
 			lpc313x_mci_write_data_pio(host);
 		    }
 		}
 
 		if (pending & SDMMC_INT_CMD_DONE) {
-		    mci_writel(RINTSTS,SDMMC_INT_CMD_DONE);  //  clear interrupt
+		    mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_CMD_DONE);  //  clear interrupt
 		    lpc313x_mci_cmd_interrupt(host, status);
 		}
 
 		if (pending & SDMMC_INT_SDIO) {
-		    mci_writel(RINTSTS,SDMMC_INT_SDIO);  //  clear interrupt
+		    mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_SDIO);  //  clear interrupt
 		    mmc_signal_sdio_irq(host->cur_slot->mmc);
 		}
 	} while (pass_count++ < 5);
@@ -1278,9 +1295,9 @@ static void lpc313x_mci_detect_change(unsigned long slot_data)
 		if (mrq) {
 			if (mrq == host->mrq) {
 			  	/* reset all blocks */
-			  	mci_writel(CTRL,(SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
+			  	mci_writel(host, SDMMC_CTRL,(SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
 			  	/* wait till resets clear */
-			  	while (mci_readl(CTRL) & (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
+			  	while (mci_readl(host, SDMMC_CTRL) & (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
 
 				host->data = NULL;
 				host->cmd = NULL;
@@ -1569,27 +1586,27 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 	SYS_SDMMC_DELAYMODES = 0x1B;
 
   	/* reset all blocks */
-  	mci_writel(CTRL,(SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
+  	mci_writel(host, SDMMC_CTRL,(SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
   	/* wait till resets clear */
-  	while (mci_readl(CTRL) & (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
+  	while (mci_readl(host, SDMMC_CTRL) & (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
 
 	 /* Clear the interrupts for the host controller */
-	mci_writel(RINTSTS, 0xFFFFFFFF);
-	mci_writel(INTMASK, 0); // disable all mmc interrupt first
+	mci_writel(host, SDMMC_RINTSTS, 0xFFFFFFFF);
+	mci_writel(host, SDMMC_INTMASK, 0); // disable all mmc interrupt first
 
   	/* Put in max timeout */
-  	mci_writel(TMOUT, 0xFFFFFFFF);
+  	mci_writel(host, SDMMC_TMOUT, 0xFFFFFFFF);
 
   	/* FIFO threshold settings  */
 #ifdef BURST_DMA
-	mci_writel(FIFOTH, ((0x1 << 28) | (0xB << 16) | (0xC << 0))); // RXMark = 11, TXMark = 12, DMA Size = 4
+	mci_writel(host, SDMMC_FIFOTH, ((0x1 << 28) | (0xB << 16) | (0xC << 0))); // RXMark = 11, TXMark = 12, DMA Size = 4
 #else
-  	mci_writel(FIFOTH, ((0x2 << 28) | (0x10 << 16) | (0x10 << 0))); // RXMark = 16, TXMark = 16, DMA Size = 8
+  	mci_writel(host, SDMMC_FIFOTH, ((0x2 << 28) | (0x10 << 16) | (0x10 << 0))); // RXMark = 16, TXMark = 16, DMA Size = 8
 #endif
 
 	/* disable clock to CIU */
-	mci_writel(CLKENA,0);
-	mci_writel(CLKSRC,0);
+	mci_writel(host, SDMMC_CLKENA,0);
+	mci_writel(host, SDMMC_CLKSRC,0);
 
 	tasklet_init(&host->tasklet, lpc313x_mci_tasklet_func, (unsigned long)host);
 	ret = request_irq(irq, lpc313x_mci_interrupt, 0, dev_name(&pdev->dev), host);
@@ -1607,9 +1624,9 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 	}
 
 	// enable interrupt for command done, data over, data empty, receive ready and error such as transmit, receive timeout, crc error
-	mci_writel(RINTSTS, 0xFFFFFFFF);
-	mci_writel(INTMASK,SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER | SDMMC_INT_TXDR | SDMMC_INT_RXDR | LPC313x_MCI_ERROR_FLAGS);
-	mci_writel(CTRL,SDMMC_CTRL_INT_ENABLE); // enable mci interrupt
+	mci_writel(host, SDMMC_RINTSTS, 0xFFFFFFFF);
+	mci_writel(host, SDMMC_INTMASK,SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER | SDMMC_INT_TXDR | SDMMC_INT_RXDR | LPC313x_MCI_ERROR_FLAGS);
+	mci_writel(host, SDMMC_CTRL,SDMMC_CTRL_INT_ENABLE); // enable mci interrupt
 
 
 	dev_info(&pdev->dev, "LPC313x MMC controller at irq %d\n", irq);
@@ -1644,8 +1661,8 @@ static int __exit lpc313x_mci_remove(struct platform_device *pdev)
 	struct clk *clk;
 	int i;
 
-	mci_writel(RINTSTS, 0xFFFFFFFF);
-	mci_writel(INTMASK, 0); // disable all mmc interrupt first
+	mci_writel(host, SDMMC_RINTSTS, 0xFFFFFFFF);
+	mci_writel(host, SDMMC_INTMASK, 0); // disable all mmc interrupt first
 
 	platform_set_drvdata(pdev, NULL);
 
@@ -1656,8 +1673,8 @@ static int __exit lpc313x_mci_remove(struct platform_device *pdev)
 	}
 
 	/* disable clock to CIU */
-	mci_writel(CLKENA,0);
-	mci_writel(CLKSRC,0);
+	mci_writel(host, SDMMC_CLKENA,0);
+	mci_writel(host, SDMMC_CLKSRC,0);
 
 	/*  turn off the mci clock here */
 	clk = clk_get(NULL, "mmc_hclk");
@@ -1681,10 +1698,11 @@ static int __exit lpc313x_mci_remove(struct platform_device *pdev)
 static int lpc313x_mci_suspend(struct platform_device *pdev, pm_message_t state)
 {
 #ifdef CONFIG_PM
+	struct lpc313x_mci *host = platform_get_drvdata(pdev);
 	struct clk *clk;
 
 	/* Disable Card clock */
-	mci_writel(CLKENA, 0);
+	mci_writel(host, SDMMC_CLKENA, 0);
 
 	/* Disable IP clocks */
 	clk = clk_get(NULL, "mmc_hclk");
@@ -1700,6 +1718,7 @@ static int lpc313x_mci_suspend(struct platform_device *pdev, pm_message_t state)
 static int lpc313x_mci_resume(struct platform_device *pdev)
 {
 #ifdef CONFIG_PM
+	struct lpc313x_mci *host = platform_get_drvdata(pdev);
 	struct clk *clk;
 	int ret;
 
@@ -1712,7 +1731,7 @@ static int lpc313x_mci_resume(struct platform_device *pdev)
 	clk_put(clk);
 
 	/* Enable Card clock */
-	mci_writel(CLKENA ,SDMMC_CLKEN_ENABLE);
+	mci_writel(host, SDMMC_CLKENA ,SDMMC_CLKEN_ENABLE);
 #endif
 	return 0;
 }
diff --git a/drivers/mmc/host/lpc31xx_mmc.h b/drivers/mmc/host/lpc31xx_mmc.h
index 654eafb..f1e9ce9 100644
--- a/drivers/mmc/host/lpc31xx_mmc.h
+++ b/drivers/mmc/host/lpc31xx_mmc.h
@@ -11,10 +11,98 @@
 
 #define MCI_SLOT 0
 
-/* Register access macros */
-#define mci_readl(reg)				\
-	__raw_readl(&SDMMC_##reg)
-#define mci_writel(reg,value)			\
-	__raw_writel((value),&SDMMC_##reg)
+/***********************************************************************
+ * SD/MMC MCI register definitions
+ **********************************************************************/
+#define SDMMC_CTRL            0x000
+#define SDMMC_PWREN           0x004
+#define SDMMC_CLKDIV          0x008
+#define SDMMC_CLKSRC          0x00c
+#define SDMMC_CLKENA          0x010
+#define SDMMC_TMOUT           0x014
+#define SDMMC_CTYPE           0x018
+#define SDMMC_BLKSIZ          0x01c
+#define SDMMC_BYTCNT          0x020
+#define SDMMC_INTMASK         0x024
+#define SDMMC_CMDARG          0x028
+#define SDMMC_CMD             0x02c
+#define SDMMC_RESP0           0x030
+#define SDMMC_RESP1           0x034
+#define SDMMC_RESP2           0x038
+#define SDMMC_RESP3           0x03c
+#define SDMMC_MINTSTS         0x040
+#define SDMMC_RINTSTS         0x044
+#define SDMMC_STATUS          0x048
+#define SDMMC_FIFOTH          0x04c
+#define SDMMC_TCBCNT          0x05c
+#define SDMMC_TBBCNT          0x060
+#define SDMMC_DEBNCE          0x064
+#define SDMMC_USRID           0x068
+#define SDMMC_VERID           0x06c
+#define SDMMC_HCON            0x070
+#define SDMMC_DATA            0x100
+#define SDMMC_DATA_ADR        (SDMMC_PHYS + 0x100)
+
+/* Control register defines */
+#define SDMMC_CTRL_CEATA_INT_EN   _BIT(11)
+#define SDMMC_CTRL_SEND_AS_CCSD   _BIT(10)
+#define SDMMC_CTRL_SEND_CCSD      _BIT(9)
+#define SDMMC_CTRL_ABRT_READ_DATA _BIT(8)
+#define SDMMC_CTRL_SEND_IRQ_RESP  _BIT(7)
+#define SDMMC_CTRL_READ_WAIT      _BIT(6)
+#define SDMMC_CTRL_DMA_ENABLE     _BIT(5)
+#define SDMMC_CTRL_INT_ENABLE     _BIT(4)
+#define SDMMC_CTRL_DMA_RESET      _BIT(2)
+#define SDMMC_CTRL_FIFO_RESET     _BIT(1)
+#define SDMMC_CTRL_RESET          _BIT(0)
+/* Clock Enable register defines */
+#define SDMMC_CLKEN_LOW_PWR      _BIT(16)
+#define SDMMC_CLKEN_ENABLE       _BIT(0)
+/* time-out register defines */
+#define SDMMC_TMOUT_DATA(n)      _SBF(8, (n))
+#define SDMMC_TMOUT_DATA_MSK     0xFFFFFF00
+#define SDMMC_TMOUT_RESP(n)      ((n) & 0xFF)
+#define SDMMC_TMOUT_RESP_MSK     0xFF
+/* card-type register defines */
+#define SDMMC_CTYPE_8BIT         _BIT(16)
+#define SDMMC_CTYPE_4BIT         _BIT(0)
+/* Interrupt status & mask register defines */
+#define SDMMC_INT_SDIO           _BIT(16)
+#define SDMMC_INT_EBE            _BIT(15)
+#define SDMMC_INT_ACD            _BIT(14)
+#define SDMMC_INT_SBE            _BIT(13)
+#define SDMMC_INT_HLE            _BIT(12)
+#define SDMMC_INT_FRUN           _BIT(11)
+#define SDMMC_INT_HTO            _BIT(10)
+#define SDMMC_INT_DTO            _BIT(9)
+#define SDMMC_INT_RTO            _BIT(8)
+#define SDMMC_INT_DCRC           _BIT(7)
+#define SDMMC_INT_RCRC           _BIT(6)
+#define SDMMC_INT_RXDR           _BIT(5)
+#define SDMMC_INT_TXDR           _BIT(4)
+#define SDMMC_INT_DATA_OVER      _BIT(3)
+#define SDMMC_INT_CMD_DONE       _BIT(2)
+#define SDMMC_INT_RESP_ERR       _BIT(1)
+#define SDMMC_INT_CD             _BIT(0)
+#define SDMMC_INT_ERROR          0xbfc2
+/* Command register defines */
+#define SDMMC_CMD_START         _BIT(31)
+#define SDMMC_CMD_CCS_EXP       _BIT(23)
+#define SDMMC_CMD_CEATA_RD      _BIT(22)
+#define SDMMC_CMD_UPD_CLK       _BIT(21)
+#define SDMMC_CMD_INIT          _BIT(15)
+#define SDMMC_CMD_STOP          _BIT(14)
+#define SDMMC_CMD_PRV_DAT_WAIT  _BIT(13)
+#define SDMMC_CMD_SEND_STOP     _BIT(12)
+#define SDMMC_CMD_STRM_MODE     _BIT(11)
+#define SDMMC_CMD_DAT_WR        _BIT(10)
+#define SDMMC_CMD_DAT_EXP       _BIT(9)
+#define SDMMC_CMD_RESP_CRC      _BIT(8)
+#define SDMMC_CMD_RESP_LONG     _BIT(7)
+#define SDMMC_CMD_RESP_EXP      _BIT(6)
+#define SDMMC_CMD_INDX(n)       ((n) & 0x1F)
+/* Status register defines */
+#define SDMMC_GET_FCNT(x)       (((x)>>17) & 0x1FF)
+#define SDMMC_FIFO_SZ           32
 
 #endif
diff --git a/drivers/mtd/nand/lpc313x_nand.c b/drivers/mtd/nand/lpc313x_nand.c
index 398e3df..d9c7f5e 100644
--- a/drivers/mtd/nand/lpc313x_nand.c
+++ b/drivers/mtd/nand/lpc313x_nand.c
@@ -59,7 +59,7 @@
  * */
 #define USE_DMA
 
-/* Maximum number of DMA descritpors in SG table
+/* Maximum number of DMA descriptors in SG table
  * */
 #define NAND_DMA_MAX_DESC 4
 
@@ -140,7 +140,7 @@ static const u32 nand_buff_phys_addr[2] = {
  */
 
 /*
- * Autoplacement pattern for 512+16 bytes small block NAND FLASH
+ * Auto-placement pattern for 512+16 bytes small block NAND FLASH
  */
 static struct nand_ecclayout nand_hw_eccoob_16 = {
 	.eccbytes	= 12,
@@ -153,7 +153,7 @@ static struct nand_ecclayout nand_hw_eccoob_16 = {
 };
 
 /*
- * Autoplacement pattern for 2048+64 bytes large block NAND FLASH
+ * Auto-placement pattern for 2048+64 bytes large block NAND FLASH
  */
 static struct nand_ecclayout nand_hw_eccoob_64 = {
 	.eccbytes	= 48,
@@ -173,7 +173,7 @@ static struct nand_ecclayout nand_hw_eccoob_64 = {
 
 #ifdef HUGE_BLOCK_SUPPORT
 /*
- * Autoplacement pattern for 4096+128 bytes large block NAND FLASH
+ * Auto-placement pattern for 4096+128 bytes large block NAND FLASH
  */
 static struct nand_ecclayout nand_hw_eccoob_128 = {
 	.eccbytes	= 96,
