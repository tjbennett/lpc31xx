Bottom: cec4685bc68f34ffefea73aade8e4016cf32868a
Top:    7c9a76f8b5d8d63e3c5ca7b2c5a3c7014a6dd899
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-03-30 19:47:49 -0400

device trees

---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
new file mode 100644
index 0000000..a8ff332
--- /dev/null
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -0,0 +1,110 @@
+/*
+ * ea3131.dts - Device Tree file for EA3131 board
+ *
+ *  Copyright (C) 2012 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Licensed under GPLv2.
+ */
+/dts-v1/;
+/include/ "lpc3131.dtsi"
+
+/ {
+	model = "Embedded Artists EA3131";
+	compatible = "ea,ea3131", "nxp,lpc3131";
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8 root=/dev/mmcblk0p3 init=/etc/preinit rw rootwait loglevel=7";
+	};
+
+	i2c@1300a000 {
+		slave-addr = <0x6E>;
+		pca9532: leds@60 {
+			#gpio-cells = <2>;
+			compatible = "nxp,pca9532";
+			reg = <0x60>;
+			gpio-controller;
+		};
+	};
+	i2c@1300a400 {
+		slave-addr = <0x6E>;
+		uda1380: codec@1a {
+			compatible = "nxp,uda1380";
+			reg = <0x1a>;
+		};
+	};
+	spi@15002000 {
+		s25sl032a@0 {
+			compatible = "code,s25sl032a";
+			spi-max-frequency = <1000000>;
+			reg = <0>;
+		};
+		ads7846@1 {
+			compatible = "ti,ads7846";
+			spi-max-frequency = <1200000>;
+			reg = <1>;
+			interrupts = <20>;
+			vref_delay_usecs = <100>;
+			x_plate_ohms = <419>;
+			y_plate_ohms = <486>;
+			pen_irq = <37>;
+			gpio_pendown = <&gpio_gpio 4 0>;
+			gpio_cs = <&gpio_ebi_i2stx_0 3 0>; 
+		};
+	};
+	sound {
+		compatible = "ea,ea3131-uda1380";
+		audio-codec = <&uda1380>;
+		i2s-controller = <&i2s>;
+		i2s-channel = <1>;
+	};
+	nand@17000800 {
+		bank-width = <2>;
+		device-width = <1>;				
+	};
+	sdmmc@18000000 {
+		slot@0 {
+			width = <4>;
+			detect-delays = <250>;
+			gpio-cd = <&gpio_cgu 7 0>;
+			gpio-power = <&gpio_ebi_i2stx_0 5 0>;
+			/* gpio-power = <&gpio_ebi_i2stx_0 5 0>; broken in hardware */
+			/* gpio-wp = <>; not implemented in hardware */
+			/* gpio-select = <>; not implemented in hardware */
+			voltage-ranges = <3200 3400>;
+		};
+	};
+	usb@19000000 {
+		vbus-over =  <&gpio_i2srx_0 2 0>;
+		vbus-interrupts = <36>;
+	};
+	sram@20000000 {
+		mpmc-config = <0x81 0 0 31 0 3 0>;
+		ssd1289@20000000 {
+			compatible = "ssd,ssd1289";
+			reg = <0x20000000 0x10000 0x20010000 0x10000>;
+		};
+	};
+	sram@20020000 {
+		/* enable oe toggle between consec reads */
+		mpmc-config = <0x81 1 1 4 1 1 2 0x24>;
+		dm9000@20020000 {
+			compatible = "davicom,dm9000";
+			reg = <0x20020000 0x100 0x20030000 0x100>;
+			interrupts = <34>;
+		};			
+	};
+	memory@30000000 {
+		reg = <0x30000000 0x4000000>;
+	};
+	gpio-leds {
+		compatible = "gpio-leds";
+		green {
+			label = "Green";
+			gpios = <&pca9532 0 1>;
+		};
+		yellow {
+			label = "Yellow";
+			gpios = <&pca9532 1 1>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/lpc3131.dtsi b/arch/arm/boot/dts/lpc3131.dtsi
new file mode 100644
index 0000000..7768a40
--- /dev/null
+++ b/arch/arm/boot/dts/lpc3131.dtsi
@@ -0,0 +1,259 @@
+/*
+ * lpc3131.dtsi - Device Tree Include file for LPC3131 family SoC
+ *
+ *  Copyright (C) 2011 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Licensed under GPLv2.
+ */
+
+/ {
+	model = "NXP LPC3131 SoC";
+	compatible = "nxp,lpc3131";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&intc>;
+
+	cpus {
+		cpu@0 {
+			compatible = "arm,arm926ejs";
+			timebase-frequency = <0>;	// from bootloader
+			bus-frequency = <0>;		// from bootloader
+			clock-frequency = <0>;		// from bootloader
+		};
+	};
+	isram0: memory@11028000 {
+		reg = <0x11028000 0x18000>;
+		interrupts = <28>;
+	};
+	isram1: memory@11040000 {
+		reg = <0x11040000 0x18000>;
+		interrupts = <29>;
+	};
+	evtr@13000000 {
+		compatible = "nxp,lpc31xx-evtr";
+		reg = <0x13000000 0x800>;
+		interrupts = <1 2 3 4>;
+	};
+	adc@13002000 {
+		compatible = "nxp,lpc31xx-adc";
+		reg = <0x13002000 0x400>;
+		interrupts = <9>;
+	};
+	wdt@13002400 {
+		compatible = "nxp,lpc31xx-wdt";
+		reg = <0x13002400 0x400>;
+		interrupts = <30>;
+	};
+	sys@13002800 {
+		compatible = "nxp,lpc31xx-sys";
+		reg = <0x13002800 0x400>;
+	};
+	gpio_ebi_mci: gpio@13003000 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x13003000 0x40>;
+		gpio-controller;
+	};
+	gpio_ebi_i2stx_0: gpio@13003040 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x13003040 0x40>;
+		gpio-controller;
+	};
+	gpio_cgu: gpio@13003080 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x13003080 0x40>;
+		gpio-controller;
+	};
+	gpio_i2srx_0: gpio@130030c0 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x130030c0 0x40>;
+		gpio-controller;
+	};
+	gpio_i2srx_1: gpio@13003100 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x13003100 0x40>;
+		gpio-controller;
+	};
+	gpio_i2stx_1: gpio@13003140 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x13003140 0x40>;
+		gpio-controller;
+	};
+	gpio_ebi: gpio@13003180 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x13003180 0x40>;
+		gpio-controller;
+	};
+	gpio_gpio: gpio@130031c0 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x130031c0 0x40>;
+		gpio-controller;
+	};
+	gpio_i2c1: gpio@13003200 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x13003200 0x40>;
+		gpio-controller;
+	};
+	gpio_spi: gpio@13003240 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x13003240 0x40>;
+		gpio-controller;
+	};
+	gpio_nand_ctrl: gpio@13003280 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x13003280 0x40>;
+		gpio-controller;
+	};
+	gpio_pwm: gpio@130032c0 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x130032c0 0x40>;
+		gpio-controller;
+	};
+	gpio_uart: gpio@13003300 {
+		#gpio-cells = <2>;
+		compatible = "nxp,lpc31xx-gpio";
+		reg = <0x13003300 0x40>;
+		gpio-controller;
+	};
+	cgu@13004000 {
+		compatible = "nxp,lpc31xx-cgu";
+		reg = <0x13004000 0x1000>;
+	};
+	rng@13006000 {
+		compatible = "nxp,lpc31xx-rng";
+		reg = <0x13006000 0x200>;
+	};
+	timer@13008000 {
+		compatible = "nxp,lpc31xx-timer";
+		reg = <0x13008000 0x400>;
+		interrupts = <5>;
+	};
+	timer@13008400 {
+		compatible = "nxp,lpc31xx-timer";
+		reg = <0x13008400 0x400>;
+		interrupts = <6>;
+	};
+	timer@13008800 {
+		compatible = "nxp,lpc31xx-timer";
+		reg = <0x13008800 0x400>;
+		interrupts = <7>;
+	};
+	timer@13008c00 {
+		compatible = "nxp,lpc31xx-timer";
+		reg = <0x13008c00 0x400>;
+		interrupts = <8>;
+	};
+	pwm@13009000 {
+		compatible = "nxp,lpc31xx-pwm";
+		reg = <0x13009000 0x200>;
+	};
+	i2c@1300a000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "nxp,lpc31xx-i2c", "nxp,pnx-i2c";
+		reg = <0x1300a000 0x400>;
+		interrupts = <11>;
+	};
+	i2c@1300a400 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "nxp,lpc31xx-i2c", "nxp,pnx-i2c";
+		reg = <0x1300a400 0x400>;
+		interrupts = <12>;
+	};
+	pcm@15000000 {
+		compatible = "nxp,lpc31xx-pcm";
+		reg = <0x15000000 0x400>;
+		interrupts = <14>;
+	};
+	lcd@15000400 {
+		compatible = "nxp,lpc31xx-lcd";
+		reg = <0x15000400 0x400>;
+		interrupts = <18>;
+	};
+	uart@15001000 {
+		compatible = "nxp,lpc31xx-uart";
+		reg = <0x15001000 0x1000>;
+		interrupts = <10>;
+		clock-frequency = <0>;		// from bootloader
+	};
+	spi@15002000 {
+		compatible = "nxp,lpc31xx-spi";
+		reg = <0x15002000 0x1000>;
+		interrupts = <19 20 21 22 23>;
+		#address-cells = <1>;
+		#size-cells = <0>;				
+	};
+	i2s: i2s@16000000 {
+		compatible = "nxp,lpc31xx-i2s";
+		reg = <0x16000000 0x1000>;
+		interrupts = <13 14 15 16>;
+	};
+	dma@17000000 {
+		compatible = "nxp,lpc31xx-dma";
+		reg = <0x17000000 0x800>;
+		interrupts = <24>;
+	};
+	nand@17000800 {
+		compatible = "nxp,lpc31xx-nand";
+		reg = <0x17000800 0x800>;
+		interrupts = <25>;
+	};
+	mpmc@17008000 {
+		compatible = "nxp,lpc31xx-mpmc";
+		reg = <0x17008000 0x1000>;
+		interrupts = <21>;
+	};
+	sdmmc@18000000 {
+		compatible = "nxp,lpc31xx-sdmmc";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x18000000 0x1000>;
+		interrupts = <26>;
+		slot@0 {
+			reg = <0>;
+			voltage-ranges = <3300 3300>;
+		};
+	};
+	usb@19000000 {
+		compatible = "nxp,lpc31xx-usb", "usb-ehci";
+		reg = <0x19000000 0x1000>;
+		interrupts = <27>;
+	};
+	sram@20000000 {
+		compatible = "nxp,lpc31xx-sram", "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x20000000 0x20000000 0x20000>;
+	};
+	sram@20020000 {
+		compatible = "nxp,lpc31xx-sram", "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x20020000 0x20020000 0x20000>;
+	};
+	memory@30000000 {
+	};
+	intc: intc@60000000 {
+		compatible = "nxp,lpc31xx-intc";
+		reg = <0x60000000 0x1000>;
+		interrupt-controller;
+		#interrupt-cells = <1>;
+	};
+	nand-buffer@70000000 {
+		compatible = "nxp,lpc31xx-nand-buffer";
+		reg = <0x70000000 0x1000>;
+		interrupts = <24>;
+	};
+};
diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
index 5298fdf..a40b338 100644
--- a/arch/arm/mach-lpc31xx/Makefile
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -4,8 +4,8 @@
 
 # Object file lists.
 
-obj-y			+= irq.o time.o generic.o i2c.o gpio.o dma.o usb.o wdt.o clock.o
-obj-$(CONFIG_GPIOLIB) += gpiolib.o
+obj-y += irq.o time.o generic.o dma.o usb.o wdt.o clock.o sram.o
+obj-$(CONFIG_OF) += dt.o
 
 
 # Specific board support
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index 0e537ec..76679ce 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -32,200 +32,33 @@
 #include <linux/spi/spi.h>
 #include <linux/leds-pca9532.h>
 #include <linux/gpio.h>
+#include <linux/of_platform.h>
 
 #include <asm/system.h>
-#include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/sizes.h>
-
 #include <asm/mach/map.h>
 #include <asm/mach-types.h>
-
 #include <asm/mach/arch.h>
+
+#include <mach/hardware.h>
 #include <mach/gpio.h>
 #include <mach/i2c.h>
 #include <mach/board.h>
 #include <mach/system.h>
+#include <mach/dt.h>
 
-static struct lpc313x_mci_irq_data irq_data = {
-	.irq = IRQ_SDMMC_CD,
-};
-
-static int mci_get_cd(u32 slot_id)
-{
-	return gpio_get_value(GPIO_MI2STX_BCK0);
-}
-
-static irqreturn_t ea313x_mci_detect_interrupt(int irq, void *data)
-{
-	struct lpc313x_mci_irq_data	*pdata = data;
-
-	/* select the opposite level senstivity */
-	int level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
-
-	irq_set_irq_type(pdata->irq, level);
-
-	/* change the polarity of irq trigger */
-	return pdata->irq_hdlr(irq, pdata->data);
-}
-
-static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
-{
-	int ret;
-	int level;
-
-	/* enable power to the slot */
-	gpio_request(GPIO_MI2STX_DATA0, "mmc power");
-	gpio_set_value(GPIO_MI2STX_DATA0, 0);
-	/* set cd pins as GPIO pins */
-	gpio_request(GPIO_MI2STX_BCK0, "mmc card detect");
-	gpio_direction_input(GPIO_MI2STX_BCK0);
-
-	/* select the opposite level senstivity */
-	level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
-	/* set card detect irq info */
-	irq_data.data = data;
-	irq_data.irq_hdlr = irqhdlr;
-	irq_set_irq_type(irq_data.irq, level);
-	ret = request_irq(irq_data.irq,
-			ea313x_mci_detect_interrupt,
-			level,
-			"mmc-cd", 
-			&irq_data);
-	/****temporary for PM testing */
-	enable_irq_wake(irq_data.irq);
-
-	return irq_data.irq;
-}
-
-static int mci_get_ro(u32 slot_id)
-{
-	return 0;
-}
-
-static int mci_get_ocr(u32 slot_id)
-{
-	return MMC_VDD_32_33 | MMC_VDD_33_34;
-}
-
-static void mci_setpower(u32 slot_id, u32 volt)
-{
-	/* on current version of EA board the card detect
-	 * pull-up in on switched power side. So can't do
-	 * power management so use the always enable power 
-	 * jumper.
-	 */
-}
-static int mci_get_bus_wd(u32 slot_id)
-{
-	return 4;
-}
-
-static void mci_exit(u32 slot_id)
-{
-	free_irq(irq_data.irq, &irq_data);
-}
-
-static struct resource lpc313x_mci_resources[] = {
-	[0] = {
-		.start  = IO_SDMMC_PHYS,
-		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_MCI,
-		.end	= IRQ_MCI,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-static struct lpc313x_mci_board ea313x_mci_platform_data = {
-	.num_slots		= 1,
-	.detect_delay_ms	= 250,
-	.init 			= mci_init,
-	.get_ro			= mci_get_ro,
-	.get_cd 		= mci_get_cd,
-	.get_ocr		= mci_get_ocr,
-	.get_bus_wd		= mci_get_bus_wd,
-	.setpower 		= mci_setpower,
-	.exit			= mci_exit,
-};
-
-static u64 mci_dmamask = 0xffffffffUL;
-static struct platform_device	lpc313x_mci_device = {
-	.name		= "lpc313x_mmc",
-	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
-	.dev		= {
-		.dma_mask		= &mci_dmamask,
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &ea313x_mci_platform_data,
-	},
-	.resource	= lpc313x_mci_resources,
-};
-
-#if defined (CONFIG_FB_SSD1289)
-static struct resource ssd1289_resource[] = {
-	[0] = {
-		.start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
-		.end   = EXT_SRAM0_PHYS + 0x00000 + 0xffff,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = EXT_SRAM0_PHYS + 0x10000 + 0x0000,
-		.end   = EXT_SRAM0_PHYS + 0x10000 + 0xffff,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device ssd1289_device = {
-	.name          = "ssd1289",
-	.id            = 0,
-	.num_resources = ARRAY_SIZE(ssd1289_resource),
-	.resource      = ssd1289_resource,
-};
-
-static void __init ea_add_device_ssd1289(void)
-{
-	MPMC_STCONFIG0 = 0x81;
-	MPMC_STWTWEN0  = 0;
-	MPMC_STWTOEN0  = 0;
-	MPMC_STWTRD0   = 31;
-	MPMC_STWTPG0   = 0;
-	MPMC_STWTWR0   = 3;
-	MPMC_STWTTURN0 = 0;
-
-	platform_device_register(&ssd1289_device);
-}
-#else
-static void __init ea_add_device_ssd1289(void) {}
-#endif /* CONFIG_SSD1289 */
 
 /*
  * DM9000 ethernet device
  */
-#if defined(CONFIG_DM9000)
-static struct resource dm9000_resource[] = {
-	[0] = {
-		.start	= EXT_SRAM1_PHYS,
-		.end	= EXT_SRAM1_PHYS + 0xFF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= EXT_SRAM1_PHYS + 0x10000,
-		.end	= EXT_SRAM1_PHYS + 0x100FF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[2] = {
-		.start	= IRQ_DM9000_ETH_INT,
-		.end	= IRQ_DM9000_ETH_INT,
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	}
-};
-/* ARM MPMC contoller as part of low power design doesn't de-assert nCS and nOE for consecutive 
+
+/* ARM MPMC contoller as part of low power design doesn't de-assert nCS and nOE for consecutive
 reads but just changes address. But DM9000 requires nCS and nOE change between address. So access
-other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time 
-such as 80 usecs. 
+other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time
+such as 80 usecs.
 LPC313x has external logic outside of MPMC IP to toggle nOE to split consecutive reads.
 The latest Apex bootloader pacth makes use of this feture.
 For this to work SYS_MPMC_WTD_DEL0 & SYS_MPMC_WTD_DEL1 should be programmed with MPMC_STWTRD0
@@ -264,199 +97,6 @@ static struct dm9000_plat_data dm9000_platdata = {
 	.inblk = dm9000_inblk,
 };
 
-static struct platform_device dm9000_device = {
-	.name		= "dm9000",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(dm9000_resource),
-	.resource	= dm9000_resource,
-	.dev		= {
-		.platform_data	= &dm9000_platdata,
-	}
-};
-static void __init ea_add_device_dm9000(void)
-{
-	/*
-	 * Configure Chip-Select 2 on SMC for the DM9000.
-	 * Note: These timings were calculated for MASTER_CLOCK = 90000000
-	 *  according to the DM9000 timings.
-	 */
-	MPMC_STCONFIG1 = 0x81;
-	MPMC_STWTWEN1 = 1;
-	MPMC_STWTOEN1 = 1;
-	MPMC_STWTRD1 = 4;
-	MPMC_STWTPG1 = 1;
-	MPMC_STWTWR1 = 1;
-	MPMC_STWTTURN1 = 2;
-	/* enable oe toggle between consec reads */
-	SYS_MPMC_WTD_DEL1 = _BIT(5) | 4;
-
-	/* Configure Interrupt pin as input, no pull-up */
-	if (gpio_request(GPIO_MNAND_RYBN3, "dm9000 interrupt"))
-		return;
-
-	gpio_direction_input(GPIO_MNAND_RYBN3);
-
-	platform_device_register(&dm9000_device);
-}
-#else
-static void __init ea_add_device_dm9000(void) {}
-#endif /* CONFIG_DM9000 */
-
-
-#if defined (CONFIG_MTD_NAND_LPC313X)
-static struct resource lpc313x_nand_resources[] = {
-	[0] = {
-		.start  = IO_NAND_PHYS,
-		.end	= IO_NAND_PHYS + IO_NAND_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start 	= IO_NAND_BUF_PHYS,
-		.end 	= IO_NAND_BUF_PHYS + IO_NAND_BUF_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[2] = {
-		.start 	= IRQ_NAND_FLASH,
-		.end 	= IRQ_NAND_FLASH,
-		.flags	= IORESOURCE_IRQ,
-	}
-};
-
-#define BLK_SIZE (2048 * 64)
-static struct mtd_partition ea313x_nand0_partitions[] = {
-	/* The EA3131 board uses the following block scheme:
-	128K: Blocks 0   - 0    - LPC31xx info and bad block table
-	384K: Blocks 1   - 3    - Apex bootloader
-	256K: Blocks 4   - 5    - Apex environment
-	4M:   Blocks 6   - 37   - Kernel image
-	16M:  Blocks 38  - 165  - Ramdisk image (if used)
-	???:  Blocks 166 - end  - Root filesystem/storage */
-	{
-		.name	= "lpc313x-rootfs",
-		.offset	= (BLK_SIZE * 166),
-		.size	= MTDPART_SIZ_FULL
-	},
-};
-
-static struct lpc313x_nand_timing ea313x_nanddev_timing = {
-	.ns_trsd	= 36,
-	.ns_tals	= 36,
-	.ns_talh	= 12,
-	.ns_tcls	= 36,
-	.ns_tclh	= 12,
-	.ns_tdrd	= 36,
-	.ns_tebidel	= 12,
-	.ns_tch		= 12,
-	.ns_tcs		= 48,
-	.ns_treh	= 24,
-	.ns_trp		= 48,
-	.ns_trw		= 24,
-	.ns_twp		= 36
-};
-
-static struct lpc313x_nand_dev_info ea313x_ndev[] = {
-	{
-		.name		= "nand0",
-		.nr_partitions	= ARRAY_SIZE(ea313x_nand0_partitions),
-		.partitions	= ea313x_nand0_partitions
-	}
-};
-
-static struct lpc313x_nand_cfg ea313x_plat_nand = {
-	.nr_devices	= ARRAY_SIZE(ea313x_ndev),
-	.devices	= ea313x_ndev,
-	.timing		= &ea313x_nanddev_timing,
-	.support_16bit	= 0,
-};
-
-static u64 nand_dmamask = 0xffffffffUL;
-static struct platform_device	lpc313x_nand_device = {
-	.name		= "lpc313x_nand",
-	.dev		= {
-		.dma_mask		= &nand_dmamask,
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data	= &ea313x_plat_nand,
-	},
-	.num_resources	= ARRAY_SIZE(lpc313x_nand_resources),
-	.resource	= lpc313x_nand_resources,
-};
-#endif
-
-#if defined(CONFIG_SPI_LPC313X)
-static struct resource lpc313x_spi_resources[] = {
-	[0] = {
-		.start	= SPI_PHYS,
-		.end	= SPI_PHYS + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_SPI,
-		.end	= IRQ_SPI,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static void spi_set_cs0_state(int cs_num, int state)
-{
-	(void) cs_num;
-	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
-}
-
-static void spi_set_cs1_state(int cs_num, int state)
-{
-	(void) cs_num;
-printk("cs1 state %d\n", state);
-	lpc313x_gpio_set_value(GPIO_MUART_CTS_N, state);
-}
-
-static void spi_set_cs2_state(int cs_num, int state)
-{
-printk("cs2 state %d\n", state);
-	(void) cs_num;
-	lpc313x_gpio_set_value(GPIO_MUART_RTS_N, state);
-}
-
-struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
-{
-	/* SPI CS0 */
-	[0] =
-	{
-		.spi_spo	= 0, /* Low clock between transfers */
-		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
-		.spi_cs_set	= spi_set_cs0_state,
-	},
-	[1] =
-	{
-		.spi_spo	= 0, /* Low clock between transfers */
-		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
-		.spi_cs_set	= spi_set_cs1_state,
-	},
-	[2] =
-	{
-		.spi_spo	= 0, /* Low clock between transfers */
-		.spi_sph	= 1, /* Data capture on first clock edge (high edge with spi_spo=0) */
-		.spi_cs_set	= spi_set_cs2_state,
-	},
-};
-
-struct lpc313x_spi_cfg lpc313x_spidata =
-{
-	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
-	.spics_cfg		= lpc313x_stdspics_cfg,
-};
-
-static u64 lpc313x_spi_dma_mask = 0xffffffffUL;
-static struct platform_device lpc313x_spi_device = {
-	.name		= "spi_lpc313x",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &lpc313x_spi_dma_mask,
-		.coherent_dma_mask = 0xffffffffUL,
-		.platform_data	= &lpc313x_spidata,
-	},
-	.num_resources	= ARRAY_SIZE(lpc313x_spi_resources),
-	.resource	= lpc313x_spi_resources,
-};
 
 /* spi_board_info.controller_data for SPI slave devices,
  * copied to spi_device.platform_data ... mostly for dma tuning
@@ -508,161 +148,10 @@ static int __init lpc313x_spidev_register(void)
 
 	return spi_register_board_info(info, 3);
 }
-arch_initcall(lpc313x_spidev_register);
-#endif
-
-#if defined(CONFIG_MTD_DATAFLASH)
-/* MTD Data FLASH driver registration */
-static int __init lpc313x_spimtd_register(void)
-{
-	struct spi_board_info info =
-	{
-		.modalias = "mtd_dataflash",
-		.max_speed_hz = 30000000,
-		.bus_num = 0,
-		.chip_select = 0,
-	};
-
-	return spi_register_board_info(&info, 1);
-}
-arch_initcall(lpc313x_spimtd_register);
-#endif
-#endif
-
-#if defined(CONFIG_SND_USE_EA3131)
-
-static u64 audio_dmamask = 0xffffffffUL;
-static struct platform_device lpc313x_uda1380_device = {
-	.name		= "lpc313x-uda1380",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &audio_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-	},
-};
-
-static struct platform_device lpc313x_i2s_device = {
-	.name		= "lpc313x-i2s",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &audio_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-	},
-};
-
-static struct platform_device lpc313x_audio_device = {
-	.name		= "lpc313x-audio",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &audio_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-	},
-};
-
-#endif
-
-static struct platform_device *devices[] __initdata = {
-	&lpc313x_mci_device,
-#if defined (CONFIG_MTD_NAND_LPC313X)
-	&lpc313x_nand_device,
+//arch_initcall(lpc313x_spidev_register);
 #endif
-#if defined(CONFIG_SPI_LPC313X)
-	&lpc313x_spi_device,
-#endif
-#if defined(CONFIG_SND_USE_EA3131)
-	&lpc313x_uda1380_device,
-	&lpc313x_i2s_device,
-	&lpc313x_audio_device,
-#endif
-};
 
-static struct map_desc ea313x_io_desc[] __initdata = {
-	{
-		.virtual	= io_p2v(EXT_SRAM0_PHYS),
-		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
-		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_SDMMC_PHYS),
-		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
-		.length		= IO_SDMMC_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_USB_PHYS),
-		.pfn		= __phys_to_pfn(IO_USB_PHYS),
-		.length		= IO_USB_SIZE,
-		.type		= MT_DEVICE
-	},
-};
-
-#define PCA9532_GPIO_BASE 0x340
-#define VBUS_PWR_EN	(6 + PCA9532_GPIO_BASE)
-#define START_STOP_LED	8  /*led5 */
-#define IDLE_LED	9  /*led6 */
-
-static struct pca9532_platform_data ea313x_leds = {
-	.gpio_base = PCA9532_GPIO_BASE,
-	.leds = {
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 1 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 2 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 3 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 4 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 5 */
-	{	.type = PCA9532_TYPE_GPIO }, /* OTP gpio */
-	{	.type = PCA9532_TYPE_GPIO }, /* V_BUS_EN gpio */
-	{	.type = PCA9532_TYPE_GPIO }, /* V_PWR_CTRL gpio */
-
-	{	.name = "ea313x:red:led5",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led6",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led7",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led8",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led9",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led10",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led11",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led12",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	},
-	.psc = { 0, 0 },
-	.pwm = { 0, 0 },
-};
 
-static struct i2c_board_info ea313x_i2c_devices[] __initdata = {
-	{
-		I2C_BOARD_INFO("pca9532", 0x60),
-		.platform_data = &ea313x_leds,
-	},
-};
 
 #if defined(CONFIG_MACH_EA3152)
 static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
@@ -675,69 +164,44 @@ static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
 void lpc313x_vbus_power(int enable)
 {
 	printk (KERN_INFO "enabling USB host vbus_power %d\n", enable);
-	gpio_set_value(VBUS_PWR_EN, enable);
+	//gpio_set_value(VBUS_PWR_EN, enable);
 }
 
-static void __init ea313x_init(void)
-{
-	lpc313x_init();
-	/* register i2cdevices */
-	lpc313x_register_i2c_devices();
-	
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	/* add DM9000 device */
-	ea_add_device_dm9000();
-	
-	ea_add_device_ssd1289();
-
-	i2c_register_board_info(0, ea313x_i2c_devices,
-		ARRAY_SIZE(ea313x_i2c_devices));
+struct of_dev_auxdata ea3131_auxdata_lookup[] __initdata = {
+	OF_DEV_AUXDATA("davicom,dm9000", EXT_SRAM1_PHYS, "dm9000", &dm9000_platdata),
+	{}
+};
 
-#if defined(CONFIG_MACH_EA3152)
-	i2c_register_board_info(1, ea3152_i2c1_devices,
-		ARRAY_SIZE(ea3152_i2c1_devices));
-#endif
+static void __init ea3131_dt_init(void)
+{
+	lpc31xx_dt_init_common(ea3131_auxdata_lookup);
 }
 
 #if defined(CONFIG_USB_EHCI_HCD)
-static void __init ea_usb_power(void)
+static int __init ea_usb_power(void)
 {
-	int ret; 
+	int ret = 0;
 
-	ret = gpio_request(VBUS_PWR_EN, "vbus power");
-	ret = gpio_direction_output(VBUS_PWR_EN, 1);
+	//ret = gpio_request(VBUS_PWR_EN, "vbus power");
+	//ret = gpio_direction_output(VBUS_PWR_EN, 1);
+	return ret;
 }
-late_initcall(ea_usb_power);
+//late_initcall(ea_usb_power);
 #endif
 
-static void __init ea313x_map_io(void)
-{
-	lpc313x_map_io();
-	iotable_init(ea313x_io_desc, ARRAY_SIZE(ea313x_io_desc));
-}
-
-#if defined(CONFIG_MACH_EA3152)
-MACHINE_START(EA3152, "NXP EA3152")
-	/* Maintainer: Durgesh Pattamatta, NXP */
-	.boot_params	= 0x30000100,
-	.map_io		= ea313x_map_io,
-	.init_irq	= lpc313x_init_irq,
-	.timer		= &lpc313x_timer,
-	.init_machine	= ea313x_init,
-MACHINE_END
-#endif
+static const char *ea3131_dt_match[] __initconst = {
+	"ea,ea3131",
+	NULL,
+};
 
-#if defined(CONFIG_MACH_EA313X)
-MACHINE_START(EA313X, "NXP EA313X")
-	/* Maintainer: Durgesh Pattamatta, NXP */
-	.map_io		= ea313x_map_io,
+DT_MACHINE_START(EA313X, "NXP EA3131 (Device Tree Support)")
+	.map_io		= lpc313x_map_io,
+	.init_early	= lpc31xx_init_early,
 	.init_irq	= lpc313x_init_irq,
 	.timer		= &lpc313x_timer,
-	.init_machine	= ea313x_init,
+	.init_machine	= ea3131_dt_init,
+	.dt_compat	= ea3131_dt_match,
 	.restart	= arch_reset,
 MACHINE_END
-#endif
 
 
diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
index 69ab97a..2bc3921 100644
--- a/arch/arm/mach-lpc31xx/clock.c
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -1062,6 +1062,8 @@ EXPORT_SYMBOL(clk_get_rate);
 static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("pnx-i2c.0", NULL, clk_i2c0)
 	_REGISTER_CLOCK("pnx-i2c.1", NULL, clk_i2c1)
+	_REGISTER_CLOCK("1300a000.i2c", NULL, clk_i2c0)
+	_REGISTER_CLOCK("1300a400.i2c", NULL, clk_i2c1)
 	_REGISTER_CLOCK(NULL, "nand_s0", clk_nand_s0)
 	_REGISTER_CLOCK(NULL, "nand_ecc", clk_nand_ecc)
 	_REGISTER_CLOCK(NULL, "nand_clk", clk_nand_clk)
@@ -1076,7 +1078,7 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "wdog_pclk", clk_wdog_pclk)
 };
 
-static int __init clk_init(void)
+int __init clk_init(void)
 {
 	int i;
 
@@ -1085,5 +1087,4 @@ static int __init clk_init(void)
 
 	return 0;
 }
-core_initcall(clk_init);
 
diff --git a/arch/arm/mach-lpc31xx/dt.c b/arch/arm/mach-lpc31xx/dt.c
new file mode 100644
index 0000000..5f1c703
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/dt.c
@@ -0,0 +1,68 @@
+/*
+ * NXP LPC3131 board support using the device tree
+ *
+ *  Copyright (C) 2010 Secret Lab Technologies Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/pgtable.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/clock.h>
+#include <mach/dt.h>
+#include <mach/system.h>
+
+static void __init lpc31xx_dt_init(void)
+{
+	lpc31xx_dt_init_common(NULL);
+}
+
+void __init lpc31xx_dt_init_common(struct of_dev_auxdata* auxdata)
+{
+	lpc313x_init();
+	of_platform_populate(NULL, of_default_bus_match_table,
+			     auxdata, NULL);
+}
+
+void __init lpc31xx_init_early(void)
+{
+}
+
+static const char *lpc31xx_dt_match[] __initconst = {
+	"ncp,lpc3130",
+	"nxp,lpc3131",
+	"nxp,lpc3152",
+	"nxp,lpc3153",
+	NULL,
+};
+
+DT_MACHINE_START(EA313X, "NXP LPC31xx (Device Tree Support)")
+	.map_io		= lpc313x_map_io,
+	.init_early	= lpc31xx_init_early,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= lpc31xx_dt_init,
+	.dt_compat	= lpc31xx_dt_match,
+	.restart	= arch_reset,
+MACHINE_END
diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index 4980a58..9765b48 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -111,66 +111,69 @@ static struct platform_device serial_device = {
 	},
 };
 
+struct platform_device lpc31xx_pcm_device = {
+	.name = "lpc31xx-pcm-audio",
+	.id = -1,
+};
 
 static struct platform_device *devices[] __initdata = {
 	&serial_device,
+	&lpc31xx_pcm_device,
 };
 
 static struct map_desc lpc313x_io_desc[] __initdata = {
 	{
-		.virtual	= io_p2v(IO_INTC_PHYS),
-		.pfn		= __phys_to_pfn(IO_INTC_PHYS),
-		.length		= IO_INTC_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_APB01_PHYS),
-		.pfn		= __phys_to_pfn(IO_APB01_PHYS),
-		.length		= IO_APB01_SIZE,
+		.virtual	= io_p2v(IO_APB1_PHYS),
+		.pfn		= __phys_to_pfn(IO_APB1_PHYS),
+		.length		= SZ_1M,
 		.type		= MT_DEVICE
 	},
 	{
 		.virtual	= io_p2v(IO_APB2_PHYS),
 		.pfn		= __phys_to_pfn(IO_APB2_PHYS),
-		.length		= IO_APB2_SIZE,
+		.length		= SZ_1M,
 		.type		= MT_DEVICE
 	},
 	{
 		.virtual	= io_p2v(IO_APB3_PHYS),
 		.pfn		= __phys_to_pfn(IO_APB3_PHYS),
-		.length		= IO_APB3_SIZE,
+		.length		= SZ_1M,
 		.type		= MT_DEVICE
 	},
 	{
 		.virtual	= io_p2v(IO_APB4_PHYS),
 		.pfn		= __phys_to_pfn(IO_APB4_PHYS),
-		.length		= IO_APB4_SIZE,
+		.length		= SZ_1M,
 		.type		= MT_DEVICE
 	},
-#if 0
 	{
-		.virtual	= io_p2v(IO_DMA_REG_PHYS),
-		.pfn		= __phys_to_pfn(IO_DMA_REG_PHYS),
-		.length		= IO_DMA_REG_SIZE,
+		.virtual	= io_p2v(IO_SDMMC_PHYS),
+		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
+		.length		= SZ_1M,
 		.type		= MT_DEVICE
 	},
-#endif
 	{
-		.virtual	= io_p2v(IO_MPMC_CFG_PHYS),
-		.pfn		= __phys_to_pfn(IO_MPMC_CFG_PHYS),
-		.length		= IO_MPMC_CFG_SIZE,
+		.virtual	= io_p2v(IO_USB_PHYS),
+		.pfn		= __phys_to_pfn(IO_USB_PHYS),
+		.length		= SZ_1M,
 		.type		= MT_DEVICE
 	},
 	{
-		.virtual	= io_p2v(IO_NAND_BUF_PHYS),
-		.pfn		= __phys_to_pfn(IO_NAND_BUF_PHYS),
-		.length		= IO_NAND_BUF_SIZE,
+		.virtual	= io_p2v(EXT_SRAM0_PHYS),
+		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(IO_INTC_PHYS),
+		.pfn		= __phys_to_pfn(IO_INTC_PHYS),
+		.length		= SZ_1M,
 		.type		= MT_DEVICE
 	},
 	{
-		.virtual	= io_p2v(IO_ISRAM0_PHYS),
-		.pfn		= __phys_to_pfn(IO_ISRAM0_PHYS),
-		.length		= IO_ISRAM0_SIZE,
+		.virtual	= io_p2v(IO_NAND_BUF_PHYS),
+		.pfn		= __phys_to_pfn(IO_NAND_BUF_PHYS),
+		.length		= SZ_1M,
 		.type		= MT_DEVICE
 	},
 };
@@ -193,9 +196,10 @@ void __init lpc313x_uart_init(void)
 	}
 }
 
-int __init lpc313x_init(void)
+void __init lpc313x_init(void)
 {
 	/* cgu init */
+	clk_init();
 	cgu_init("");
 	/* Switch on the UART clocks */
 	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
diff --git a/arch/arm/mach-lpc31xx/gpio.c b/arch/arm/mach-lpc31xx/gpio.c
deleted file mode 100644
index fd09c8b..0000000
--- a/arch/arm/mach-lpc31xx/gpio.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/*  linux/arch/arm/mach-lpc313x/gpio.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- * GPIO driver for LPC313x & LPC315x.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/string.h>
-
-#include <asm/errno.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-
-
-void lpx313x_gpio_func_mode(int gpio)
-{
-	unsigned long flags;
-	int port = (gpio & GPIO_PORT_MASK);
-	int pin = 1 << (gpio & GPIO_PIN_MASK);
-
-	raw_local_irq_save(flags);
-
-	GPIO_M1_RESET(port) = pin; 
-	GPIO_M0_SET(port) = pin;
-
-	raw_local_irq_restore(flags);
-
-}
-
-EXPORT_SYMBOL(lpx313x_gpio_func_mode);
-
-
-
-
-int lpc313x_gpio_direction_output(unsigned gpio, int value)
-{
-	unsigned long flags;
-	int port = (gpio & GPIO_PORT_MASK);
-	int pin = 1 << (gpio & GPIO_PIN_MASK);
-
-	raw_local_irq_save(flags);
-
-	GPIO_M1_SET(port) = pin; 
-
-	if(value) {
-		GPIO_M0_SET(port) = pin;
-	} else {
-		GPIO_M0_RESET(port) = pin;
-	}
-
-	raw_local_irq_restore(flags);
-	return 0;
-}
-
-EXPORT_SYMBOL(lpc313x_gpio_direction_output);
-
-
-#ifndef CONFIG_GPIOLIB
-int gpio_is_valid(unsigned gpio)
-{
-	int ret = 1;
-	int port = (gpio & GPIO_PORT_MASK);
-	int pin_no = (gpio & GPIO_PIN_MASK);
-
-
-	if ( (gpio & ~(GPIO_PORT_MASK | GPIO_PIN_MASK)) &&
-	     ((port >> 5) > 12)) {
-		return 0;
-	} 
-	switch (port) {
-		case IOCONF_EBI_I2STX_0:
-			if (pin_no > 9)
-				ret = 0;
-			break;
-		case IOCONF_PWM:
-		case IOCONF_CGU:
-			if (pin_no > 0)
-				ret = 0;
-			break;
-		case IOCONF_I2SRX_0:
-		case IOCONF_I2SRX_1:
-			if (pin_no > 2)
-				ret = 0;
-			break;
-		case IOCONF_I2STX_1:
-			if (pin_no > 3)
-				ret = 0;
-			break;
-		case IOCONF_EBI:
-			if (pin_no > 15)
-				ret = 0;
-			break;
-		case IOCONF_GPIO:
-			if (pin_no > 14)
-				ret = 0;
-			break;
-		case IOCONF_UART:
-		case IOCONF_I2C1:
-			if (pin_no > 1)
-				ret = 0;
-			break;
-		case IOCONF_SPI:
-			if (pin_no > 4)
-				ret = 0;
-			break;
-		case IOCONF_NAND_CTRL:
-			if (pin_no > 3)
-				ret = 0;
-			break;
-	}
-	return ret;
-}
-
-EXPORT_SYMBOL(gpio_is_valid);
-#endif
-
diff --git a/arch/arm/mach-lpc31xx/i2c.c b/arch/arm/mach-lpc31xx/i2c.c
deleted file mode 100644
index ea1e4b2..0000000
--- a/arch/arm/mach-lpc31xx/i2c.c
+++ /dev/null
@@ -1,163 +0,0 @@
-/*  linux/arch/arm/mach-lpc313x/i2c.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- * I2C initialization for LPC313x.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/i2c.h>
-#include <linux/i2c-pnx.h>
-#include <linux/platform_device.h>
-#include <linux/err.h>
-#include <linux/slab.h>
-#include <mach/hardware.h>
-#include <mach/i2c.h>
-#include <mach/gpio.h>
-#include <mach/irqs.h>
-
-#define LPC313x_I2C0_SLV_ADDR            __REG (I2C0_PHYS + 0x014)
-#define LPC313x_I2C1_SLV_ADDR            __REG (I2C1_PHYS + 0x014)
-
-static int set_clock_run(struct platform_device *pdev)
-{
-	if (pdev->id == 0)
-		cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 1);
-	else
-		cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 1);
-
-	udelay(2);
-	return 0;
-}
-
-static int set_clock_stop(struct platform_device *pdev)
-{
-	if (pdev->id == 0)
-		cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 0);
-	else
-		cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 0);
-
-	return 0;
-}
-
-static int i2c_lpc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	int retval = 0;
-#ifdef CONFIG_PM
-	retval = set_clock_stop(pdev);
-#endif
-	return retval;
-}
-
-static int i2c_lpc_resume(struct platform_device *pdev)
-{
-	int retval = 0;
-#ifdef CONFIG_PM
-	retval = set_clock_run(pdev);
-#endif
-	return retval;
-}
-
-static u32 calculate_input_freq(struct platform_device *pdev)
-{
-	return (FFAST_CLOCK/1000000);
-}
-
-/* disable this until device tree patch */
-#if 0
-
-static struct i2c_pnx_data lpc_pnx_data0 = {
-	.name = I2C_CHIP_NAME "0",
-	.base = I2C0_PHYS,
-	.irq = IRQ_I2C0,
-};
-
-static struct i2c_pnx_data lpc_pnx_data1 = {
-	.name = I2C_CHIP_NAME "1",
-	.base = I2C1_PHYS,
-	.irq = IRQ_I2C1,
-};
-
-static struct i2c_pnx_algo_data i2c0_algo_data;
-static struct i2c_pnx_algo_data i2c1_algo_data;
-
-static struct i2c_pnx_algo_data i2c0_algo_data = {
-	.adapter = {
-		.name = I2C_CHIP_NAME "0",
-		.algo_data = &i2c0_algo_data,
-	},
-	.i2c_pnx = &lpc_pnx_data0,
-};
-
-static struct i2c_pnx_algo_data i2c1_algo_data = {
-	.adapter = {
-		.name = I2C_CHIP_NAME "1",
-		.algo_data = &i2c1_algo_data,
-	},
-	.i2c_pnx = &lpc_pnx_data1,
-};
-
-static struct platform_device i2c0_device = {
-	.name = "pnx-i2c",
-	.id = 0,
-	.dev = {
-		.platform_data = &lpc_pnx_data0,
-	},
-};
-
-static struct platform_device i2c1_device = {
-	.name = "pnx-i2c",
-	.id = 1,
-	.dev = {
-		.platform_data = &lpc_pnx_data1,
-	},
-};
-
-static struct platform_device *devices[] __initdata = {
-	&i2c0_device,
-	&i2c1_device,
-};
-
-void __init lpc313x_register_i2c_devices(void)
-{
-	cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 1);
-	cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 1);
-
-	/* Enable I2C1 signals */
-	GPIO_DRV_IP(IOCONF_I2C1, 0x3);
-
-#if defined (CONFIG_MACH_VAL3153) || defined (CONFIG_MACH_EA313X)
-	/* on EA and VAL boards UDA1380 is connected to I2C1
-	 * whose slave address is same as LPC313x's default slave
-	 * adress causing bus contention errors. So change the
-	 * deafult slave address register value of LPC313x here.
-	 */
-	LPC313x_I2C0_SLV_ADDR = 0x06E;
-	LPC313x_I2C1_SLV_ADDR = 0x06E;
-#endif
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-}
-
-#else
-void __init lpc313x_register_i2c_devices(void)
-{
-}
-#endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/board.h b/arch/arm/mach-lpc31xx/include/mach/board.h
index 5fe9ac2..c8d01ea 100644
--- a/arch/arm/mach-lpc31xx/include/mach/board.h
+++ b/arch/arm/mach-lpc31xx/include/mach/board.h
@@ -32,7 +32,7 @@
 
 extern void __init lpc313x_map_io(void);
 extern void __init lpc313x_init_irq(void);
-extern int __init lpc313x_init(void);
+extern void __init lpc313x_init(void);
 extern int __init lpc313x_register_i2c_devices(void);
 extern void lpc313x_vbus_power(int enable);
 extern int lpc313x_entering_suspend_mem(void);
@@ -120,32 +120,5 @@ struct lpc313x_spi_cfg {
 #define MAX_MCI_SLOTS		1
 #endif
 
-/*
- * the board-type specific routines
- */
-struct lpc313x_mci_board {
-	u32 num_slots;
-	u32 detect_delay_ms; /* delay in mS before detecting cards after interrupt */
-	int (*init)(u32 slot_id, irq_handler_t , void *);
-	int (*get_ro)(u32 slot_id);
-	int (*get_cd)(u32 slot_id);
-	int (*get_ocr)(u32 slot_id);
-	int (*get_bus_wd)(u32 slot_id);
-	/*
-	 * Enable power to selected slot and set voltage to desired level.
-	 * Voltage levels are specified using MMC_VDD_xxx defines defined
-	 * in linux/mmc/host.h file.
-	 */
-	void (*setpower)(u32 slot_id, u32 volt);
-	void (*exit)(u32 slot_id);
-	void (*select_slot)(u32 slot_id);
-};
-
-struct lpc313x_mci_irq_data {
-	u32 irq;
-	irq_handler_t irq_hdlr;
-	void* data;
-};
-
 #endif /*__MACH_BOARD_H*/
 
diff --git a/arch/arm/mach-lpc31xx/include/mach/clock.h b/arch/arm/mach-lpc31xx/include/mach/clock.h
index d7058b6..eb038b3 100644
--- a/arch/arm/mach-lpc31xx/include/mach/clock.h
+++ b/arch/arm/mach-lpc31xx/include/mach/clock.h
@@ -653,4 +653,7 @@ struct clk {
 	CGU_CLOCK_ID_T id;
 };
 
+
+int clk_init(void);
+
 #endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/constants.h b/arch/arm/mach-lpc31xx/include/mach/constants.h
index 81233a6..b645671 100644
--- a/arch/arm/mach-lpc31xx/include/mach/constants.h
+++ b/arch/arm/mach-lpc31xx/include/mach/constants.h
@@ -70,8 +70,8 @@
 
 /* SoC CPU IO addressing */
 /* APB0 & APB1 address range*/
-#define IO_APB01_PHYS     (0x13000000)
-#define IO_APB01_SIZE     (0x0000B000)
+#define IO_APB1_PHYS      (0x13000000)
+#define IO_APB1_SIZE      (0x0000B000)
 /* APB2 address range*/
 #define IO_APB2_PHYS      (0x15000000)
 #define IO_APB2_SIZE      (0x00003000)
@@ -82,8 +82,8 @@
 #define IO_APB4_PHYS      (0x17000000)
 #define IO_APB4_SIZE      (0x00001000)
 /* DMA registers address range*/
-#define IO_DMA_REG_PHYS  (DMA_PHYS)
-#define IO_DMA_REG_SIZE  (0x0000800)
+#define IO_DMA_REG_PHYS   (DMA_PHYS)
+#define IO_DMA_REG_SIZE   (0x0000800)
 /* MPMC config registers address range*/
 #define IO_MPMC_CFG_PHYS  (0x17008000)
 #define IO_MPMC_CFG_SIZE  (0x00001000)
diff --git a/arch/arm/mach-lpc31xx/include/mach/dt.h b/arch/arm/mach-lpc31xx/include/mach/dt.h
new file mode 100644
index 0000000..f4eb877
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/dt.h
@@ -0,0 +1,9 @@
+#ifndef LPC31XX_DT
+#define LPC31XX_DT
+
+void lpc31xx_dt_init_common(struct of_dev_auxdata* auxdata);
+void lpc31xx_init_early(void);
+void lpc31xx_restart(char mode, const char *cmd);
+
+#endif
+
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
index 50dc8a7..4ff6533 100644
--- a/arch/arm/mach-lpc31xx/irq.c
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -24,6 +24,8 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/timer.h>
+#include <linux/of_irq.h>
+#include <linux/irqdomain.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -199,6 +201,10 @@ ROUTER_HDLR(2)
 ROUTER_HDLR(3)
 #endif /* IRQ_EVTR3_END */
 
+static const struct of_device_id intc_of_match[] __initconst = {
+	{ .compatible = "nxp,lpc31xx-intc", },
+	{},
+};
 
 void __init lpc313x_init_irq(void)
 {
@@ -206,6 +212,8 @@ void __init lpc313x_init_irq(void)
 	int i, j;
 	u32 bank, bit_pos;
 
+	irq_domain_generate_simple(intc_of_match, 0x60000000, 0);
+
 	/* enable clock to interrupt controller */
 	cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, 1);
 	cgu_clk_en_dis(CGU_SB_INTC_CLK_ID, 1);
diff --git a/arch/arm/mach-lpc31xx/sram.c b/arch/arm/mach-lpc31xx/sram.c
new file mode 100644
index 0000000..ad77715
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/sram.c
@@ -0,0 +1,113 @@
+/*
+ * LPC313x sram driver
+ *
+ * Copyright (C) 2012 Jon Smirl <jonsmirl@gmail.com?
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+
+/* Note that these seven registers can be assigned sequentially */
+#define MPMC_SEQ_COUNT        7
+#define MPMC_STCONFIG      0x00
+#define MPMC_STWTWEN       0x04
+#define MPMC_STWTOEN       0x08
+#define MPMC_STWTRD        0x0C
+#define MPMC_STWTPG        0x10
+#define MPMC_STWTWR        0x14
+#define MPMC_STWTTURN      0x18
+
+static int lpc313x_sram_probe(struct platform_device *pdev)
+{
+	const unsigned int *prop;
+	const unsigned int *ranges;
+	int len, count, i;
+	volatile u32 *base;
+
+	prop = of_get_property(pdev->dev.of_node, "mpmc-config", &len);
+	if (!prop)
+		return 0;
+	count = len / sizeof(*prop);
+
+	ranges = of_get_property(pdev->dev.of_node, "ranges", &len);
+	if (!prop) {
+		dev_err(&pdev->dev, "Ranges property missing on SRAM DT");
+		return -EINVAL;
+	}
+
+	if (__be32_to_cpup(ranges) == EXT_SRAM0_PHYS) {
+		base = &MPMC_STCONFIG0;
+	} else if (__be32_to_cpup(ranges) == EXT_SRAM1_PHYS) {
+		base = &MPMC_STCONFIG1;
+	} else {
+		dev_err(&pdev->dev, "SRAM Ranges is not a valid base address");
+		return  -EINVAL;
+	}
+
+	/* Note that the seven MPMC register are sequential */
+	for (i = 0; (i < MPMC_SEQ_COUNT) && (count >= 0); i++) {
+		*base = __be32_to_cpup(prop);
+		base++;prop++;count--;
+		if (count <= 0)
+			return 0;
+	}
+	/* enable OE toggle between consecutive reads */
+	if (count == 1) {
+		if (__be32_to_cpup(ranges) == EXT_SRAM0_PHYS)
+			SYS_MPMC_WTD_DEL0 = __be32_to_cpup(prop);
+		else
+			SYS_MPMC_WTD_DEL1 = __be32_to_cpup(prop);
+		return 0;
+	}
+	dev_err(&pdev->dev, "SRAM too many parameters");
+	return  -EINVAL;
+}
+
+static const struct of_device_id lpc313x_sram_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-sram" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_sram_of_match);
+
+static struct platform_driver lpc313x_sram_driver = {
+	.probe = lpc313x_sram_probe,
+	.driver = {
+			.owner = THIS_MODULE,
+			.name = "lpc313x-sram",
+			.of_match_table = lpc313x_sram_of_match,
+		   },
+};
+
+static int __init lpc313x_sram_init(void)
+{
+	return platform_driver_register(&lpc313x_sram_driver);
+}
+
+static void __exit lpc313x_sram_exit(void)
+{
+	platform_driver_unregister(&lpc313x_sram_driver);
+}
+
+module_init(lpc313x_sram_init);
+module_exit(lpc313x_sram_exit);
+
+MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com>");
+MODULE_DESCRIPTION("Driver for the LPC313x sram");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-lpc31xx/usb.c b/arch/arm/mach-lpc31xx/usb.c
index 57699b7..9c1c8b0 100644
--- a/arch/arm/mach-lpc31xx/usb.c
+++ b/arch/arm/mach-lpc31xx/usb.c
@@ -38,6 +38,7 @@
 #include <linux/io.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <linux/of_gpio.h>
 
 #include <asm/irq.h>
 #include <asm/system.h>
@@ -95,6 +96,7 @@
 #define OTGSC_INT_STAT_MASK (0x007F0000)
 
 /*-------------------------------------------------------------------------*/
+#if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
 static struct resource lpc313x_usb_resource[] = {
 	[0] = {
 		.start = (u32) (USBOTG_PHYS),
@@ -107,6 +109,7 @@ static struct resource lpc313x_usb_resource[] = {
 		.flags = IORESOURCE_IRQ,
 	}
 };
+#endif
 
 struct lpc313x_usb_board_t {
 	/* timer for VBUS enable */
@@ -117,20 +120,6 @@ struct lpc313x_usb_board_t {
 
 static struct lpc313x_usb_board_t lpc313x_usb_brd;
 
-static u64 usb_dmamask = 0xffffffffUL;;
-static void	lpc313x_usb_release(struct device *dev);
-
-struct fsl_usb2_platform_data lpc313x_fsl_config = {
-#if defined(CONFIG_USB_OTG) || (defined(CONFIG_USB_EHCI_HCD) && defined(CONFIG_USB_GADGET_FSL_USB2))
-	.operating_mode = FSL_USB2_DR_OTG,
-#elif defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_EHCI_HCD)
-	.operating_mode = FSL_USB2_DR_DEVICE,
-#elif !defined(CONFIG_USB_GADGET_FSL_USB2) && defined(CONFIG_USB_EHCI_HCD)
-	.operating_mode = FSL_USB2_DR_HOST,
-#endif
-	.phy_mode = FSL_USB2_PHY_UTMI,
-};
-
 #if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
 
 static struct platform_device lpc313x_udc_device = {
@@ -139,7 +128,6 @@ static struct platform_device lpc313x_udc_device = {
 		.dma_mask          = &usb_dmamask,
 		.coherent_dma_mask = 0xffffffff,
 		.release           = lpc313x_usb_release,
-		.platform_data     = &lpc313x_fsl_config,
 	},
 	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
 	.resource      = lpc313x_usb_resource,
@@ -148,26 +136,21 @@ static struct platform_device lpc313x_udc_device = {
 
 #if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_OTG)
 
+#ifndef CONFIG_OF
 static struct platform_device lpc313x_ehci_device = {
 	.name		= "lpc-ehci",
 	.dev = {
 		.dma_mask          = &usb_dmamask,
 		.coherent_dma_mask = 0xffffffff,
 		.release           = lpc313x_usb_release,
-		.platform_data     = &lpc313x_fsl_config,
 	},
 	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
 	.resource      = lpc313x_usb_resource,
 };
 #endif
+#endif
 
 
-/*-------------------------------------------------------------------------*/
-static void	lpc313x_usb_release(struct device *dev)
-{
-	// do nothing
-}
-
 static irqreturn_t lpc313x_vbus_ovrc_irq(int irq, void *data)
 {
 	struct lpc313x_usb_board_t* brd = data;
@@ -198,6 +181,7 @@ static void lpc313x_vbusen_timer(unsigned long data)
 /*-------------------------------------------------------------------------*/
 int __init usbotg_init(void)
 {
+	int over;
 	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
 	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
 	int retval = 0;
@@ -242,21 +226,25 @@ int __init usbotg_init(void)
 	} else {
 #if defined(CONFIG_USB_EHCI_HCD)
 		/* register host */
+#ifndef CONFIG_OF
 		printk(KERN_INFO "Registering USB host 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
 		retval = platform_device_register(&lpc313x_ehci_device);
 		if ( 0 != retval )
 			printk(KERN_INFO "Can't register lpc313x_ehci_device device\n");
-
+#endif
 		/* Create VBUS enable timer */
 		setup_timer(&lpc313x_usb_brd.vbus_timer, lpc313x_vbusen_timer,
 				(unsigned long)&lpc313x_usb_brd);
 
 #if defined(CONFIG_MACH_EA313X) || defined(CONFIG_MACH_EA3152)
 		/* set thw I2SRX_WS0 pin as GPIO_IN for vbus overcurrent flag */
-		retval = gpio_request(GPIO_I2SRX_WS0, "vbus overcurrent");
+#if 0
+		over = of_get_named_gpio(np, "vbus-over", 0);
+		retval = gpio_request(over, "vbus overcurrent");
 		if ( 0 != retval )
-			printk(KERN_INFO "Can't acquire GPIO_I2SRX_WS0\n");
-		gpio_direction_input(GPIO_I2SRX_WS0);
+			printk(KERN_INFO "Can't acquire vbus-over GPIO\n");
+		gpio_direction_input(over);
+#endif
 		lpc313x_usb_brd.vbus_ovrc_irq = IRQ_EA_VBUS_OVRC;
 
 #else
diff --git a/arch/arm/mach-lpc31xx/wdt.c b/arch/arm/mach-lpc31xx/wdt.c
index 0cf5d37..160e8cc 100644
--- a/arch/arm/mach-lpc31xx/wdt.c
+++ b/arch/arm/mach-lpc31xx/wdt.c
@@ -24,6 +24,7 @@
 #include <mach/constants.h>
 #include <mach/irqs.h>
 
+#ifndef CONFIG_OF
 static struct resource watchdog_resources[] = {
 	{
 		.start = WDT_PHYS,
@@ -45,3 +46,4 @@ static int __init wdt_device_init(void)
 }
 
 arch_initcall(wdt_device_init);
+#endif
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index fa10df6..a33f4bf 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_GPIO_IT8761E)	+= gpio-it8761e.o
 obj-$(CONFIG_GPIO_JANZ_TTL)	+= gpio-janz-ttl.o
 obj-$(CONFIG_ARCH_KS8695)	+= gpio-ks8695.o
 obj-$(CONFIG_GPIO_LANGWELL)	+= gpio-langwell.o
+obj-$(CONFIG_ARCH_LPC31XX)	+= gpio-lpc31xx.o
 obj-$(CONFIG_ARCH_LPC32XX)	+= gpio-lpc32xx.o
 obj-$(CONFIG_GPIO_MAX730X)	+= gpio-max730x.o
 obj-$(CONFIG_GPIO_MAX7300)	+= gpio-max7300.o
diff --git a/arch/arm/mach-lpc31xx/gpiolib.c b/drivers/gpio/gpio-lpc31xx.c
similarity index 70%
rename from arch/arm/mach-lpc31xx/gpiolib.c
rename to drivers/gpio/gpio-lpc31xx.c
index 1566ec5..6e523fa 100644
--- a/arch/arm/mach-lpc31xx/gpiolib.c
+++ b/drivers/gpio/gpio-lpc31xx.c
@@ -15,6 +15,9 @@
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
 #include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -166,6 +169,27 @@ struct lpc313x_gpio_chip lpc313x_gpios[] = {
 	},
 };
 
+int lpc313x_gpio_direction_output(unsigned gpio, int value)
+{
+	unsigned long flags;
+	int port = (gpio & GPIO_PORT_MASK);
+	int pin = 1 << (gpio & GPIO_PIN_MASK);
+
+	raw_local_irq_save(flags);
+
+	GPIO_M1_SET(port) = pin;
+
+	if(value) {
+		GPIO_M0_SET(port) = pin;
+	} else {
+		GPIO_M0_RESET(port) = pin;
+	}
+
+	raw_local_irq_restore(flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(lpc313x_gpio_direction_output);
 
 static inline int lpc3131_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 {
@@ -187,37 +211,58 @@ static inline void lpc3131_gpio_set_value(struct gpio_chip *chip, unsigned offse
 	lpc313x_gpio_set_value(chip->base + offset, value);
 }
 
-__init void lpc313x_gpiolib_add(struct lpc313x_gpio_chip *chip)
+static int lpc313x_gpiochip_remove(struct platform_device *ofdev)
+{
+	return -EBUSY;
+}
+
+static int __devinit lpc313x_simple_gpiochip_probe(struct platform_device *ofdev)
 {
-	struct gpio_chip *gc = &chip->chip;
+	struct of_mm_gpio_chip *chip;
+	struct gpio_chip *gc;
 	int ret;
 
-	BUG_ON(!chip->base);
-	BUG_ON(!gc->label);
-	BUG_ON(!gc->ngpio);
-
-	if (!gc->direction_input)
-		gc->direction_input = lpc3131_gpio_direction_input;
-	if (!gc->direction_output)
-		gc->direction_output = lpc3131_gpio_direction_output;
-	if (!gc->set)
-		gc->set = lpc3131_gpio_set_value;
-	if (!gc->get)
-		gc->get = lpc3131_gpio_get_value;
-
-	/* gpiochip_add() prints own failure message on error. */
-	ret = gpiochip_add(gc);
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	gc = &chip->gc;
+
+	gc->ngpio            = 32;
+	gc->direction_input  = lpc3131_gpio_direction_input;
+	gc->direction_output = lpc3131_gpio_direction_output;
+	gc->get              = lpc3131_gpio_get_value;
+	gc->set              = lpc3131_gpio_set_value;
+
+	ret = of_mm_gpiochip_add(ofdev->dev.of_node, chip);
+	if (ret)
+		return ret;
+
+	return 0;
 }
 
+static const struct of_device_id lpc313x_simple_gpiochip_match[] = {
+	{ .compatible = "nxp,lpc31xx-gpio", },
+	{}
+};
+
+static struct platform_driver lpc313x_simple_gpiochip_driver = {
+	.driver = {
+		.name = "lpc31xx-gpio",
+		.owner = THIS_MODULE,
+		.of_match_table = lpc313x_simple_gpiochip_match,
+	},
+	.probe = lpc313x_simple_gpiochip_probe,
+	.remove = lpc313x_gpiochip_remove,
+};
+
 static __init int lpc313x_gpiolib_init(void)
 {
-	struct lpc313x_gpio_chip *chip = lpc313x_gpios;
-	int gpn;
-
-	for (gpn = 0; gpn < ARRAY_SIZE(lpc313x_gpios); gpn++, chip++)
-		lpc313x_gpiolib_add(chip);
+	if (platform_driver_register(&lpc313x_simple_gpiochip_driver))
+		printk(KERN_ERR "Unable to register simple GPIO driver\n");
 
 	return 0;
 }
 
+/* Make sure we get initialised before anyone else tries to use us */
 core_initcall(lpc313x_gpiolib_init);
diff --git a/drivers/input/touchscreen/ads7846.c b/drivers/input/touchscreen/ads7846.c
index 23fd901..2ec9049 100644
--- a/drivers/input/touchscreen/ads7846.c
+++ b/drivers/input/touchscreen/ads7846.c
@@ -32,6 +32,8 @@
 #include <linux/spi/ads7846.h>
 #include <linux/regulator/consumer.h>
 #include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
 #include <asm/irq.h>
 
 /*
@@ -965,11 +967,12 @@ static int __devinit ads7846_setup_pendown(struct spi_device *spi, struct ads784
 	 * reason the touchscreen isn't hooked up, we don't need to access
 	 * the pendown state.
 	 */
-
+printk("JDS pd 1a\n");
 	if (pdata->get_pendown_state) {
 		ts->get_pendown_state = pdata->get_pendown_state;
 	} else if (gpio_is_valid(pdata->gpio_pendown)) {
 
+		printk("JDS pd 1b\n");
 		err = gpio_request_one(pdata->gpio_pendown, GPIOF_IN,
 				       "ads7846_pendown");
 		if (err) {
@@ -978,6 +981,7 @@ static int __devinit ads7846_setup_pendown(struct spi_device *spi, struct ads784
 				pdata->gpio_pendown, err);
 			return err;
 		}
+		printk("JDS pd 1c\n");
 
 		ts->gpio_pendown = pdata->gpio_pendown;
 
@@ -985,6 +989,7 @@ static int __devinit ads7846_setup_pendown(struct spi_device *spi, struct ads784
 		dev_err(&spi->dev, "no get_pendown_state nor gpio_pendown?\n");
 		return -EINVAL;
 	}
+	printk("JDS pd 1d\n");
 
 	return 0;
 }
@@ -1192,20 +1197,64 @@ static void __devinit ads7846_setup_spi_msg(struct ads7846 *ts,
 	spi_message_add_tail(x, m);
 }
 
+#if defined(CONFIG_OF)
+static struct ads7846_platform_data ads7846_pdata[] = {
+		{
+				.model = 7843
+		},{
+				.model = 7845
+		},{
+				.model = 7846
+		},{
+				.model = 7873
+		},
+};
+static const struct of_device_id ads7846_of_match[] = {
+	{ .compatible = "ti,tsc2046", .data = &ads7846_pdata[2], },
+	{ .compatible = "ti,ads7843", .data = &ads7846_pdata[0], },
+	{ .compatible = "ti,ads7845", .data = &ads7846_pdata[1], },
+	{ .compatible = "ti,ads7846", .data = &ads7846_pdata[2], },
+	{ .compatible = "ad,ad7873", .data = &ads7846_pdata[3], },
+	{ .compatible = "ad,ad7843", .data = &ads7846_pdata[0], },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ads7846_of_match);
+#endif
+
 static int __devinit ads7846_probe(struct spi_device *spi)
 {
 	struct ads7846 *ts;
 	struct ads7846_packet *packet;
 	struct input_dev *input_dev;
 	struct ads7846_platform_data *pdata = spi->dev.platform_data;
+	const struct of_device_id *of_id = of_match_device(ads7846_of_match, &spi->dev);
 	unsigned long irq_flags;
-	int err;
+	struct device_node *nc;
+	const __be32 *prop;
+	int len, err;
 
 	if (!spi->irq) {
 		dev_dbg(&spi->dev, "no IRQ?\n");
 		return -ENODEV;
 	}
 
+#ifdef CONFIG_OF
+	nc = spi->dev.of_node;
+	spi->dev.platform_data = pdata = of_id ? of_id->data : NULL;
+
+	prop = of_get_property(nc, "vref_delay_usecs", &len);
+	if (prop && len >= sizeof(*prop))
+		pdata->vref_delay_usecs = be32_to_cpup(prop);
+	prop = of_get_property(nc, "x_plate_ohms", &len);
+	if (prop && len >= sizeof(*prop))
+		pdata->x_plate_ohms = be32_to_cpup(prop);
+	prop = of_get_property(nc, "y_plate_ohms", &len);
+	if (prop && len >= sizeof(*prop))
+		pdata->y_plate_ohms = be32_to_cpup(prop);
+	pdata->gpio_pendown = of_get_named_gpio(nc, "gpio_pendown", 0);
+printk("JDS - pendown %x\n", pdata->gpio_pendown);
+#endif
+
 	if (!pdata) {
 		dev_dbg(&spi->dev, "no platform data?\n");
 		return -ENODEV;
@@ -1271,14 +1320,17 @@ static int __devinit ads7846_probe(struct spi_device *spi)
 	} else {
 		ts->filter = ads7846_no_filter;
 	}
+	printk("JDS 10\n");
 
 	err = ads7846_setup_pendown(spi, ts);
 	if (err)
 		goto err_cleanup_filter;
+	printk("JDS 11\n");
 
 	if (pdata->penirq_recheck_delay_usecs)
 		ts->penirq_recheck_delay_usecs =
 				pdata->penirq_recheck_delay_usecs;
+	printk("JDS 12\n");
 
 	ts->wait_for_sync = pdata->wait_for_sync ? : null_wait_for_sync;
 
@@ -1301,6 +1353,7 @@ static int __devinit ads7846_probe(struct spi_device *spi)
 			0, 0);
 	input_set_abs_params(input_dev, ABS_PRESSURE,
 			pdata->pressure_min, pdata->pressure_max, 0, 0);
+	printk("JDS 13\n");
 
 	ads7846_setup_spi_msg(ts, pdata);
 
@@ -1310,6 +1363,7 @@ static int __devinit ads7846_probe(struct spi_device *spi)
 		dev_err(&spi->dev, "unable to get regulator: %d\n", err);
 		goto err_free_gpio;
 	}
+	printk("JDS 14\n");
 
 	err = regulator_enable(ts->reg);
 	if (err) {
@@ -1319,6 +1373,7 @@ static int __devinit ads7846_probe(struct spi_device *spi)
 
 	irq_flags = pdata->irq_flags ? : IRQF_TRIGGER_FALLING;
 	irq_flags |= IRQF_ONESHOT;
+	printk("JDS 15\n");
 
 	err = request_threaded_irq(spi->irq, ads7846_hard_irq, ads7846_irq,
 				   irq_flags, spi->dev.driver->name, ts);
@@ -1330,6 +1385,7 @@ static int __devinit ads7846_probe(struct spi_device *spi)
 				  ads7846_hard_irq, ads7846_irq,
 				  irq_flags, spi->dev.driver->name, ts);
 	}
+	printk("JDS 16\n");
 
 	if (err) {
 		dev_dbg(&spi->dev, "irq %d busy?\n", spi->irq);
@@ -1341,6 +1397,7 @@ static int __devinit ads7846_probe(struct spi_device *spi)
 		goto err_free_irq;
 
 	dev_info(&spi->dev, "touchscreen, irq %d\n", spi->irq);
+	printk("JDS 17\n");
 
 	/*
 	 * Take a first sample, leaving nPENIRQ active and vREF off; avoid
@@ -1358,9 +1415,11 @@ static int __devinit ads7846_probe(struct spi_device *spi)
 	err = input_register_device(input_dev);
 	if (err)
 		goto err_remove_attr_group;
+	printk("JDS 18\n");
 
 	device_init_wakeup(&spi->dev, pdata->wakeup);
 
+	printk("JDS 19\n");
 	return 0;
 
  err_remove_attr_group:
@@ -1428,6 +1487,9 @@ static struct spi_driver ads7846_driver = {
 		.name	= "ads7846",
 		.owner	= THIS_MODULE,
 		.pm	= &ads7846_pm,
+#ifdef CONFIG_OF
+		.of_match_table = ads7846_of_match,
+#endif
 	},
 	.probe		= ads7846_probe,
 	.remove		= __devexit_p(ads7846_remove),
diff --git a/drivers/leds/leds-pca9532.c b/drivers/leds/leds-pca9532.c
index ceccab4..611f6ff 100644
--- a/drivers/leds/leds-pca9532.c
+++ b/drivers/leds/leds-pca9532.c
@@ -444,6 +444,34 @@ exit:
 	return err;
 }
 
+#ifdef CONFIG_OF
+/* for now make everything into a GPIO under OF */
+/* LED support needs to be integrated with OF gpio-leds */
+static struct pca9532_platform_data of_gpios = {
+	.gpio_base = -1,
+	.leds = {
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	},
+	.psc = { 0, 0 },
+	.pwm = { 0, 0 },
+};
+#endif
+
 static int pca9532_probe(struct i2c_client *client,
 	const struct i2c_device_id *id)
 {
@@ -451,8 +479,12 @@ static int pca9532_probe(struct i2c_client *client,
 	struct pca9532_platform_data *pca9532_pdata = client->dev.platform_data;
 	int err;
 
+#ifdef CONFIG_OF
+	pca9532_pdata = &of_gpios;
+#else
 	if (!pca9532_pdata)
 		return -EIO;
+#endif
 
 	if (!i2c_check_functionality(client->adapter,
 		I2C_FUNC_SMBUS_BYTE_DATA))
diff --git a/drivers/mmc/host/lpc31xx_mmc.c b/drivers/mmc/host/lpc31xx_mmc.c
index 73d67e7..a9a7dfa 100644
--- a/drivers/mmc/host/lpc31xx_mmc.c
+++ b/drivers/mmc/host/lpc31xx_mmc.c
@@ -37,6 +37,10 @@
 #include <linux/delay.h>
 #include <linux/irq.h>
 #include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
 
 #include "lpc31xx_mmc.h"
 #include <mach/irqs.h>
@@ -72,6 +76,7 @@ enum lpc313x_mci_state {
 	STATE_SENDING_STOP,
 	STATE_DATA_ERROR,
 };
+
 /*forward declaration */
 struct lpc313x_mci_slot;
 
@@ -105,7 +110,7 @@ struct lpc313x_mci {
 	u32			bus_hz;
 	u32			current_speed;
 	struct platform_device	*pdev;
-	struct lpc313x_mci_board *pdata;
+	int slot_count;
 	struct lpc313x_mci_slot	*slot[MAX_MCI_SLOTS];
 };
 
@@ -126,6 +131,11 @@ struct lpc313x_mci_slot {
 	int			id;
 	int			irq;
 
+	int			gpio_cd;
+	int			gpio_wp;
+	int			gpio_power;
+	int			gpio_select;
+
 	struct timer_list	detect_timer;
 };
 
@@ -418,7 +428,7 @@ static int lpc313x_mci_submit_data_dma(struct lpc313x_mci *host, struct mmc_data
 		return -EINVAL;
 
 	for_each_sg(data->sg, sg, data->sg_len, i) {
-		if (sg->offset & 3 || sg->length & 3)
+		if ((sg->offset & 3) || (sg->length & 3))
 			return -EINVAL;
 	}
 
@@ -578,6 +588,27 @@ void lpc313x_mci_setup_bus(struct lpc313x_mci_slot *slot)
 	mci_writel(CTYPE, slot->ctype);
 }
 
+static void lpc313x_mci_select_slot(struct lpc313x_mci_slot *slot, int enable)
+{
+	if (slot->gpio_select >= 0) {
+		printk("lpc313x_mci_select_slot %d\n", slot->gpio_select);
+		gpio_set_value(slot->gpio_select, enable);
+	}
+}
+
+static void lpc313x_mci_set_power(struct lpc313x_mci_slot *slot, int enable)
+{
+	/* on current version of EA board the card detect
+	 * pull-up in on switched power side. So can't do
+	 * power management so use the always enable power
+	 * jumper.
+	 */
+	if (slot->gpio_power >= 0) {
+		printk("lpc313x_mci_set_power %d\n", slot->gpio_power);
+		gpio_set_value(slot->gpio_power, enable);
+	}
+}
+
 static void lpc313x_mci_start_request(struct lpc313x_mci *host,
 		struct lpc313x_mci_slot *slot)
 {
@@ -588,8 +619,11 @@ static void lpc313x_mci_start_request(struct lpc313x_mci *host,
 
 	mrq = slot->mrq;
 	/* now select the proper slot */
-	if (host->pdata->select_slot)
-		host->pdata->select_slot(slot->id);
+	if (host->cur_slot != slot) {
+		if (host->cur_slot)
+			lpc313x_mci_select_slot(host->cur_slot, 0);
+		lpc313x_mci_select_slot(slot, 1);
+	}
 
 	/* Slot specific timing and width adjustment */
 	lpc313x_mci_setup_bus(slot);
@@ -701,31 +735,28 @@ static void lpc313x_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 
 
-static int lpc313x_mci_get_ro(struct mmc_host *mmc)
+static int lpc313x_mci_get_wp(struct mmc_host *mmc)
 {
 	int			read_only = -ENOSYS;
 	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
-	struct lpc313x_mci_board *brd = slot->host->pdata;
 
-	if (brd->get_ro != NULL) {
-		read_only = brd->get_ro(slot->id);
+	if (slot->gpio_wp >= 0) {
+		read_only =  gpio_get_value(slot->gpio_wp);
 		dev_dbg(&mmc->class_dev, "card is %s\n",
 				read_only ? "read-only" : "read-write");
 	}
-
 	return read_only;
 }
 
 
-static int lpc313x_mci_get_cd(struct mmc_host *mmc)
+static int lpc313x_mci_get_cd(struct lpc313x_mci_slot *slot)
 {
 	int			present = -ENOSYS;
-	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
-	struct lpc313x_mci_board *brd = slot->host->pdata;
-
-	present = !brd->get_cd(slot->id);
-	dev_vdbg(&mmc->class_dev, "card is %spresent\n", present ? "" : "not ");
 
+	if (slot->gpio_cd >= 0) {
+		present = !gpio_get_value(slot->gpio_cd);
+		dev_vdbg(&slot->mmc->class_dev, "card is %spresent\n", present ? "" : "not ");
+	}
 	return present;
 }
 
@@ -746,8 +777,7 @@ static void lpc313x_mci_enable_sdio_irq(struct mmc_host *host, int enable)
 static const struct mmc_host_ops lpc313x_mci_ops = {
 	.request	= lpc313x_mci_request,
 	.set_ios	= lpc313x_mci_set_ios,
-	.get_ro		= lpc313x_mci_get_ro,
-	.get_cd		= lpc313x_mci_get_cd,
+	.get_ro		= lpc313x_mci_get_wp,
 	.enable_sdio_irq= lpc313x_mci_enable_sdio_irq,
 };
 
@@ -1226,7 +1256,7 @@ static void lpc313x_mci_detect_change(unsigned long slot_data)
 		return;
 
 	enable_irq(slot->irq);
-	present = !host->pdata->get_cd(slot->id);
+	present = !gpio_get_value(slot->gpio_cd);
 	present_old = test_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
 	dev_vdbg(&slot->mmc->class_dev, "detect change: %d (was %d)\n",
 			present, present_old);
@@ -1239,17 +1269,8 @@ static void lpc313x_mci_detect_change(unsigned long slot_data)
 		spin_lock(&host->lock);
 
 		/* Power up slot */
-		if (present != 0) {
-			if (host->pdata->setpower)
-				host->pdata->setpower(slot->id, slot->mmc->ocr_avail);
-
-			set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-		} else {
-			if (host->pdata->setpower)
-				host->pdata->setpower(slot->id, 0);
-
-			clear_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-		}
+		lpc313x_mci_set_power(slot, present);
+		set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
 
 
 		/* Clean up queue if present */
@@ -1313,6 +1334,10 @@ static irqreturn_t lpc313x_mci_detect_interrupt(int irq, void *dev_id)
 {
 	struct lpc313x_mci_slot	*slot = dev_id;
 
+	/* select the opposite level senstivity */
+	int level =  lpc313x_mci_get_cd(slot) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+	irq_set_irq_type(slot->irq, level);
+
 	/*
 	 * Disable interrupts until the pin has stabilized and check
 	 * the state then. Use mod_timer() since we may be in the
@@ -1325,10 +1350,13 @@ static irqreturn_t lpc313x_mci_detect_interrupt(int irq, void *dev_id)
 }
 
 static int __init
-lpc313x_mci_init_slot(struct lpc313x_mci *host, unsigned int id)
+lpc313x_mci_init_slot(struct lpc313x_mci *host, struct device_node *np)
 {
 	struct mmc_host			*mmc;
 	struct lpc313x_mci_slot		*slot;
+	const u32 *voltage_ranges;
+	const int *width;
+	int i, ret, num_ranges, level;
 
 	mmc = mmc_alloc_host(sizeof(struct lpc313x_mci_slot), &host->pdev->dev);
 
@@ -1336,44 +1364,89 @@ lpc313x_mci_init_slot(struct lpc313x_mci *host, unsigned int id)
 		return -ENOMEM;
 
 	slot = mmc_priv(mmc);
-	slot->id = id;
+	slot->id = host->slot_count++;
+
 	slot->mmc = mmc;
 	slot->host = host;
+	slot->gpio_cd = of_get_named_gpio(np, "gpio-cd", 0);
+	if (slot->gpio_cd >= 0) {
+		gpio_request(slot->gpio_cd, "mmc cd");
+		gpio_direction_input(slot->gpio_cd);
+	}
+	slot->gpio_wp = of_get_named_gpio(np, "gpio-wp", 0);
+	if (slot->gpio_wp >= 0)
+		gpio_request(slot->gpio_cd, "mmc wp");
+	slot->gpio_power = of_get_named_gpio(np, "gpio-power", 0);
+	if (slot->gpio_power >= 0)
+		gpio_request(slot->gpio_cd, "mmc power");
+	slot->gpio_select = of_get_named_gpio(np, "gpio-select", 0);
+	if (slot->gpio_select >= 0)
+		gpio_request(slot->gpio_select, "mmc select");
 
 	mmc->ops = &lpc313x_mci_ops;
 	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 510);
 	mmc->f_max = host->bus_hz/2; //max f is clock to mmc_clk/2
-	if (host->pdata->get_ocr)
-		mmc->ocr_avail = host->pdata->get_ocr(id);
-	else
-		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	voltage_ranges = of_get_property(np, "voltage-ranges", &num_ranges);
+	num_ranges = num_ranges / sizeof(*voltage_ranges) / 2;
+	if (!voltage_ranges || !num_ranges) {
+		dev_err(&host->pdev->dev, "OF: voltage-ranges unspecified\n");
+		ret = -EINVAL;
+		goto err_ocr;
+	}
+
+	for (i = 0; i < num_ranges; i++) {
+		const int j = i * 2;
+		u32 mask;
+
+		mask = mmc_vddrange_to_ocrmask(be32_to_cpu(voltage_ranges[j]),
+					       be32_to_cpu(voltage_ranges[j + 1]));
+		if (!mask) {
+			ret = -EINVAL;
+			dev_err(&host->pdev->dev, "OF: voltage-range #%d is invalid\n", i);
+			goto err_ocr;
+		}
+		mmc->ocr_avail |= mask;
+	}
 
 	/* Start with slot power disabled, will be enabled when card is detected */
-	if (host->pdata->setpower)
-		host->pdata->setpower(id, 0);
+	lpc313x_mci_set_power(slot, 0);
 
 	mmc->caps = MMC_CAP_SDIO_IRQ;
-	if (host->pdata->get_bus_wd)
-		if (host->pdata->get_bus_wd(slot->id) >= 4)
-			mmc->caps |= MMC_CAP_4_BIT_DATA;
+	width = of_get_property(np, "width", NULL);
+	if (*width == 4)
+		mmc->caps |= MMC_CAP_4_BIT_DATA;
+	else if (*width == 8)
+		mmc->caps |= MMC_CAP_8_BIT_DATA;
 
 	mmc->max_blk_size = 65536; /* BLKSIZ is 16 bits*/
 	mmc->max_blk_count = 512;
 	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
 	mmc->max_seg_size = mmc->max_req_size;
 
-	/* call board init */
-	slot->irq = host->pdata->init(id, lpc313x_mci_detect_interrupt, slot);
+	slot->irq = of_get_property(np, "interrupts", NULL);
+	/* select the opposite level sensitivity */
+	level =  lpc313x_mci_get_cd(slot) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+
+	/* set card detect irq info */
+	irq_set_irq_type(slot->irq, level);
+	ret = request_irq(slot->irq,
+			lpc313x_mci_detect_interrupt,
+			level,
+			"mmc-cd",
+			slot);
+	/****temporary for PM testing */
+	enable_irq_wake(slot->irq);
+
 	/* Assume card is present initially */
-	if(!host->pdata->get_cd(id))
+	if(!gpio_get_value(slot->gpio_cd))
 		set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
 	else
 		clear_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
 
-	host->slot[id] = slot;
+	host->slot[host->slot_count++] = slot;
 	mmc_add_host(mmc);
 
-
 #if defined (CONFIG_DEBUG_FS)
 	lpc313x_mci_init_debugfs(slot);
 #endif
@@ -1383,14 +1456,16 @@ lpc313x_mci_init_slot(struct lpc313x_mci *host, unsigned int id)
 			(unsigned long)slot);
 
 	return 0;
+err_ocr:
+	return ret;
 }
 
 static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
 		unsigned int id)
 {
 	/* Shutdown detect IRQ and kill detect thread */
-	if (slot->host->pdata->exit)
-		slot->host->pdata->exit(id);
+	free_irq(slot->irq, slot);
+
 	del_timer_sync(&slot->detect_timer);
 
 	/* Debugfs stuff is cleaned up by mmc core */
@@ -1401,22 +1476,26 @@ static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
 	mmc_free_host(slot->mmc);
 }
 
+static const struct of_device_id lpc313x_mci_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-sdmmc" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_mci_of_match);
 
 static int lpc313x_mci_probe(struct platform_device *pdev)
 {
-	struct lpc313x_mci		*host;
-	struct resource			*regs;
-	struct lpc313x_mci_board	*pdata;
+	struct device_node *node;
+	struct device_node *np = pdev->dev.of_node;
+	struct lpc313x_mci *host;
+	struct resource *regs;
 	struct clk *clk;
-	int				irq;
-	int				ret = 0;
-	int i;
+	int irq;
+	int ret = 0;
 
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs)
 		return -ENXIO;
 
-
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
@@ -1424,21 +1503,7 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 	host = kzalloc(sizeof(struct lpc313x_mci), GFP_KERNEL);
 	if (!host)
 		return -ENOMEM;
-
 	host->pdev = pdev;
-	host->pdata = pdata = pdev->dev.platform_data;
-	if (!pdata) {
-		dev_err(&pdev->dev, "Platform data missing\n");
-		ret = -ENODEV;
-		goto err_freehost;
-	}
-
-	if (((pdata->num_slots > 1) && !(pdata->select_slot)) ||
-	     !(pdata->get_ro) || !(pdata->get_cd) || !(pdata->init)) {
-		dev_err(&pdev->dev, "Platform data wrong\n");
-		ret = -ENODEV;
-		goto err_freehost;
-	}
 
 	spin_lock_init(&host->lock);
 	INIT_LIST_HEAD(&host->queue);
@@ -1483,6 +1548,7 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 		goto err_freemap;
 	}
 #endif
+
 	clk = clk_get(NULL, "mmc_cclk_in");
 	host->bus_hz = clk_get_rate(clk); //40000000;
 	clk_put(clk);
@@ -1527,12 +1593,11 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, host);
 
-	/* We need at least one slot to succeed ####pd####*/
-	for (i = 0; i < host->pdata->num_slots; i++) {
-		ret = lpc313x_mci_init_slot(host, i);
+	for_each_child_of_node(np, node) {
+		ret = lpc313x_mci_init_slot(host, node);
 		if (ret) {
-		    ret = -ENODEV;
-		    goto err_init_slot;
+			ret = -ENODEV;
+			goto err_init_slot;
 		}
 	}
 
@@ -1548,10 +1613,10 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 
 err_init_slot:
 	/* De-init any initialized slots */
-	while (i > 0) {
-		if (host->slot[i])
-			lpc313x_mci_cleanup_slot(host->slot[i], i);
-		i--;
+	while (host->slot_count > 0) {
+		if (host->slot[host->slot_count])
+			lpc313x_mci_cleanup_slot(host->slot[host->slot_count], host->slot_count);
+		host->slot_count--;
 	}
 	free_irq(irq, host);
 err_dmaunmap:
@@ -1579,7 +1644,7 @@ static int __exit lpc313x_mci_remove(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, NULL);
 
-	for (i = 0; i < host->pdata->num_slots; i++) {
+	for (i = 0; i < host->slot_count; i++) {
 		dev_dbg(&pdev->dev, "remove slot %d\n", i);
 		if (host->slot[i])
 			lpc313x_mci_cleanup_slot(host->slot[i], i);
@@ -1652,7 +1717,11 @@ static struct platform_driver lpc313x_mci_driver = {
 	.resume     = lpc313x_mci_resume,
 	.remove		= __exit_p(lpc313x_mci_remove),
 	.driver		= {
-		.name		= "lpc313x_mmc",
+		.name	= "lpc313x_mmc",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = lpc313x_mci_of_match,
+#endif
 	},
 };
 
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 7c60ddd..5ceeb94 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -834,6 +834,7 @@ static int __devinit m25p_probe(struct spi_device *spi)
 	 * a chip ID, try the JEDEC id commands; they'll work for most
 	 * newer chips, even if we don't recognize the particular chip.
 	 */
+
 	data = spi->dev.platform_data;
 	if (data && data->type) {
 		const struct spi_device_id *plat_id;
@@ -849,7 +850,8 @@ static int __devinit m25p_probe(struct spi_device *spi)
 			id = plat_id;
 		else
 			dev_warn(&spi->dev, "unrecognized id %s\n", data->type);
-	}
+	} else
+		id = jedec_probe(spi);
 
 	info = (void *)id->driver_data;
 
@@ -988,11 +990,21 @@ static int __devexit m25p_remove(struct spi_device *spi)
 	return 0;
 }
 
+#ifdef CONFIG_OF
+static const struct of_device_id m25p80_dt_ids[] = {
+	{ .compatible = "st,m25", },
+	{ /* sentinel */ }
+};
+#else
+#define m25p80_dt_ids NULL
+#endif
+
 
 static struct spi_driver m25p80_driver = {
 	.driver = {
 		.name	= "m25p80",
 		.owner	= THIS_MODULE,
+		.of_match_table = m25p80_dt_ids,
 	},
 	.id_table	= m25p_ids,
 	.probe	= m25p_probe,
diff --git a/drivers/mtd/nand/lpc313x_nand.c b/drivers/mtd/nand/lpc313x_nand.c
index 3e76633..398e3df 100644
--- a/drivers/mtd/nand/lpc313x_nand.c
+++ b/drivers/mtd/nand/lpc313x_nand.c
@@ -1306,6 +1306,56 @@ static void lpc313x_nand_update_chip(struct lpc313x_nand_info *info,
 	chip->ecc.prepad = 0;
 }
 
+#ifdef CONFIG_OF
+#define BLK_SIZE (2048 * 64)
+static struct mtd_partition ea313x_nand0_partitions[] = {
+	/* The EA3131 board uses the following block scheme:
+	128K: Blocks 0   - 0    - LPC31xx info and bad block table
+	384K: Blocks 1   - 3    - Apex bootloader
+	256K: Blocks 4   - 5    - Apex environment
+	4M:   Blocks 6   - 37   - Kernel image
+	16M:  Blocks 38  - 165  - Ramdisk image (if used)
+	???:  Blocks 166 - end  - Root filesystem/storage */
+	{
+		.name	= "lpc313x-rootfs",
+		.offset	= (BLK_SIZE * 166),
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct lpc313x_nand_timing ea313x_nanddev_timing = {
+	.ns_trsd	= 36,
+	.ns_tals	= 36,
+	.ns_talh	= 12,
+	.ns_tcls	= 36,
+	.ns_tclh	= 12,
+	.ns_tdrd	= 36,
+	.ns_tebidel	= 12,
+	.ns_tch		= 12,
+	.ns_tcs		= 48,
+	.ns_treh	= 24,
+	.ns_trp		= 48,
+	.ns_trw		= 24,
+	.ns_twp		= 36
+};
+
+static struct lpc313x_nand_dev_info ea313x_ndev[] = {
+	{
+		.name		= "nand0",
+		.nr_partitions	= ARRAY_SIZE(ea313x_nand0_partitions),
+		.partitions	= ea313x_nand0_partitions
+	}
+};
+
+static struct lpc313x_nand_cfg ea313x_plat_nand = {
+	.nr_devices	= ARRAY_SIZE(ea313x_ndev),
+	.devices	= ea313x_ndev,
+	.timing		= &ea313x_nanddev_timing,
+	.support_16bit	= 0,
+};
+#endif
+
+
 /*
  * Called by device layer when it finds a device matching
  * one our driver can handled. This code checks to see if
@@ -1335,6 +1385,10 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 	/* Register driver data with platform */
 	platform_set_drvdata(pdev, host);
 
+#ifdef CONFIG_OF
+	plat = &ea313x_plat_nand;
+#endif
+
 	host->dev = &pdev->dev;
 	host->platform = plat;
 	host->irq = irq;
@@ -1342,7 +1396,7 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 
 	/* Exit if no platform data */
 	if (plat == NULL) {
-		dev_err(&pdev->dev, "No memory for flash info\n");
+		dev_err(&pdev->dev, "No platform data\n");
 		goto exit_error;
 	}
 
@@ -1543,6 +1597,15 @@ static int lpc313x_nand_suspend(struct platform_device *pdev, pm_message_t pm)
 #define lpc313x_nand_suspend NULL
 #endif
 
+#if defined(CONFIG_OF)
+static const struct of_device_id lpc313x_nand_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-nand" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_nand_of_match);
+#endif
+
+
 static struct platform_driver lpc313x_nand_driver = {
 	.probe		= lpc313x_nand_probe,
 	.remove		= lpc313x_nand_remove,
@@ -1551,6 +1614,9 @@ static struct platform_driver lpc313x_nand_driver = {
 	.driver = {
 		.name = "lpc313x_nand",
 		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = lpc313x_nand_of_match,
+#endif
 	},
 };
 
diff --git a/drivers/net/ethernet/davicom/dm9000.c b/drivers/net/ethernet/davicom/dm9000.c
index f7ca4cc..f8fd607 100644
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@ -1679,11 +1679,22 @@ dm9000_drv_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id dm9000_of_match[] = {
+	{ .compatible = "davicom,dm9000" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dm9000_of_match);
+#endif
+
 static struct platform_driver dm9000_driver = {
 	.driver	= {
 		.name    = "dm9000",
 		.owner	 = THIS_MODULE,
 		.pm	 = &dm9000_drv_pm_ops,
+#ifdef CONFIG_OF
+		.of_match_table = dm9000_of_match,
+#endif
 	},
 	.probe   = dm9000_probe,
 	.remove  = __devexit_p(dm9000_drv_remove),
diff --git a/drivers/spi/spi-lpc313x.c b/drivers/spi/spi-lpc313x.c
index aa99f79..0157806 100644
--- a/drivers/spi/spi-lpc313x.c
+++ b/drivers/spi/spi-lpc313x.c
@@ -45,6 +45,7 @@
 #include <mach/registers.h>
 #include <mach/dma.h>
 #include <mach/board.h>
+#include <mach/gpio.h>
 
 /* Register access macros */
 #define spi_readl(reg) __raw_readl(&SPI_##reg)
@@ -745,6 +746,57 @@ static int lpc313x_spi_transfer(struct spi_device *spi, struct spi_message *m)
 	return 0;
 }
 
+#ifdef CONFIG_OF
+static void spi_set_cs0_state(int cs_num, int state)
+{
+	(void) cs_num;
+	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
+}
+
+static void spi_set_cs1_state(int cs_num, int state)
+{
+	(void) cs_num;
+printk("cs1 state %d\n", state);
+	lpc313x_gpio_set_value(GPIO_MUART_CTS_N, state);
+}
+
+static void spi_set_cs2_state(int cs_num, int state)
+{
+printk("cs2 state %d\n", state);
+	(void) cs_num;
+	lpc313x_gpio_set_value(GPIO_MUART_RTS_N, state);
+}
+
+struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
+{
+	/* SPI CS0 */
+	[0] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs0_state,
+	},
+	[1] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clofck edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs1_state,
+	},
+	[2] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 1, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs2_state,
+	},
+};
+
+struct lpc313x_spi_cfg lpc313x_spidata =
+{
+	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
+	.spics_cfg		= lpc313x_stdspics_cfg,
+};
+#endif
+
 /*
  * SPI driver probe
  */
@@ -773,6 +825,9 @@ static int __init lpc313x_spi_probe(struct platform_device *pdev)
 
 	/* Is a board specific configuration available? */
 	spidat->psppcfg = (struct lpc313x_spi_cfg *) pdev->dev.platform_data;
+#ifdef CONFIG_OF
+	spidat->psppcfg = &lpc313x_spidata;
+#endif
 	if (spidat->psppcfg == NULL)
 	{
 		/* No platform data, exit */
@@ -876,6 +931,9 @@ static int __init lpc313x_spi_probe(struct platform_device *pdev)
 		ret = -EBUSY;
 		goto errout4;
 	}
+#ifdef CONFIG_OF
+	master->dev.of_node = of_node_get(pdev->dev.of_node);
+#endif
 
 	ret = spi_register_master(master);
 	if (ret)
@@ -972,6 +1030,14 @@ static int lpc313x_spi_resume(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id lpc313x_spi_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-spi" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_spi_of_match);
+#endif
+
 static struct platform_driver lpc313x_spi_driver = {
 	.probe		= lpc313x_spi_probe,
 	.remove		= __devexit_p(lpc313x_spi_remove),
@@ -980,6 +1046,9 @@ static struct platform_driver lpc313x_spi_driver = {
 	.driver		= {
 		.name	= "spi_lpc313x",
 		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = lpc313x_spi_of_match,
+#endif
 	},
 };
 
diff --git a/drivers/usb/host/ehci-lpc.c b/drivers/usb/host/ehci-lpc.c
index 9932f36..6044cc9 100644
--- a/drivers/usb/host/ehci-lpc.c
+++ b/drivers/usb/host/ehci-lpc.c
@@ -76,6 +76,17 @@ static const struct hc_driver lpc_ehci_hc_driver = {
 	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
 };
 
+struct fsl_usb2_platform_data lpc313x_fsl_config = {
+#if defined(CONFIG_USB_OTG) || (defined(CONFIG_USB_EHCI_HCD) && defined(CONFIG_USB_GADGET_FSL_USB2))
+	.operating_mode = FSL_USB2_DR_OTG,
+#elif defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_EHCI_HCD)
+	.operating_mode = FSL_USB2_DR_DEVICE,
+#elif !defined(CONFIG_USB_GADGET_FSL_USB2) && defined(CONFIG_USB_EHCI_HCD)
+	.operating_mode = FSL_USB2_DR_HOST,
+#endif
+	.phy_mode = FSL_USB2_PHY_UTMI,
+};
+
 static int lpc_ehci_probe(struct platform_device *pdev)
 {
 	struct fsl_usb2_platform_data *pdata;
@@ -89,7 +100,7 @@ static int lpc_ehci_probe(struct platform_device *pdev)
 		return -ENODEV;
 
 	/* Need platform data for setup */
-	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+	pdata = &lpc313x_fsl_config;
 	if (!pdata) {
 		dev_err(&pdev->dev,
 			"No platform data for %s.\n", dev_name(&pdev->dev));
@@ -342,6 +353,14 @@ static int lpc313x_ehci_resume(struct platform_device * pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id ehci_lpc_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-usb" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ehci_lpc_of_match);
+#endif
+
 static struct platform_driver ehci_lpc_driver = {
 	.probe = lpc_ehci_probe,
 	.remove = lpc_ehci_remove,
@@ -353,6 +372,9 @@ static struct platform_driver ehci_lpc_driver = {
 		.suspend = lpc_ehci_suspend,
 		.resume  = lpc_ehci_resume,
 #endif
+#ifdef CONFIG_OF
+		.of_match_table = ehci_lpc_of_match,
+#endif
 	},
 };
 
diff --git a/drivers/video/ssd1289.c b/drivers/video/ssd1289.c
index 21537ce..327cfb1 100644
--- a/drivers/video/ssd1289.c
+++ b/drivers/video/ssd1289.c
@@ -496,11 +496,23 @@ out:
 	return ret;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id ssd1289_of_match[] = {
+	{ .compatible = "ssd,ssd1289" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ssd1289_of_match);
+#endif
+
 static struct platform_driver ssd1289_driver = {
 	.probe = ssd1289_probe,
-	.driver = {
-		   .name = "ssd1289",
-		   },
+	.driver		= {
+		.name	= "ssd1289",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = ssd1289_of_match,
+#endif
+	},
 };
 
 static int __init ssd1289_init(void)
diff --git a/drivers/watchdog/wdt_lpc313x.c b/drivers/watchdog/wdt_lpc313x.c
index 22e12e2..f5c4978 100644
--- a/drivers/watchdog/wdt_lpc313x.c
+++ b/drivers/watchdog/wdt_lpc313x.c
@@ -329,12 +329,23 @@ static int lpc313x_wdt_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id lpc313x_wdt_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-wdt" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_wdt_of_match);
+#endif
+
 static struct platform_driver lpc313x_wdt_driver = {
 	.probe = lpc313x_wdt_probe,
 	.remove = __devexit_p(lpc313x_wdt_remove),
 	.driver = {
-		   .owner = THIS_MODULE,
-		   .name = "lpc313x-wdt",
+			.owner = THIS_MODULE,
+			.name = "lpc313x-wdt",
+#ifdef CONFIG_OF
+			.of_match_table = lpc313x_wdt_of_match,
+#endif
 		   },
 };
 
diff --git a/dt_config b/dt_config
new file mode 100644
index 0000000..5ac5df2
--- /dev/null
+++ b/dt_config
@@ -0,0 +1,1839 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.3.0 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_ARCH_USES_GETTIMEOFFSET=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+CONFIG_ARCH_LPC31XX=y
+# CONFIG_GPIO_PCA953X is not set
+
+#
+# System MMU
+#
+
+#
+# LPC313x Implementations
+#
+CONFIG_MACH_EA313X=y
+# CONFIG_MACH_EA3152 is not set
+# CONFIG_MACH_VAL3153 is not set
+# CONFIG_MACH_VAL3154 is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+# CONFIG_SCHED_HRTICK is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_NR_BANKS=8
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_LEDS=y
+# CONFIG_LEDS_TIMER is not set
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="console=ttyS0,115200n8 root=/dev/ram0 rw"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_UNIX is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_ARPD=y
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+CONFIG_IEEE802154=y
+# CONFIG_IEEE802154_6LOWPAN is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_BQL=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_OF_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
+# CONFIG_MTD_DATAFLASH_OTP is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_LPC313X=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Device Tree and Open Firmware support
+#
+CONFIG_PROC_DEVICETREE=y
+# CONFIG_OF_SELFTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_I2C=y
+CONFIG_OF_NET=y
+CONFIG_OF_SPI=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_XIP=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_NEW_LPC313x_IO=y
+CONFIG_LPC313x_ADC=y
+CONFIG_LPC313x_PWM=y
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+CONFIG_IEEE802154_DRIVERS=y
+# CONFIG_IEEE802154_FAKEHARD is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+CONFIG_DM9000=y
+# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_FARADAY=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTGMAC100 is not set
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_SMC91X is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_ATH_COMMON is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_P54_COMMON is not set
+CONFIG_RT2X00=y
+CONFIG_RT2500USB=y
+CONFIG_RT73USB=y
+CONFIG_RT2800USB=y
+CONFIG_RT2800USB_RT33XX=y
+CONFIG_RT2800USB_RT35XX=y
+# CONFIG_RT2800USB_RT53XX is not set
+# CONFIG_RT2800USB_UNKNOWN is not set
+CONFIG_RT2800_LIB=y
+CONFIG_RT2X00_LIB_USB=y
+CONFIG_RT2X00_LIB=y
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_RT2X00_LIB_LEDS=y
+# CONFIG_RT2X00_DEBUG is not set
+# CONFIG_RTL8192CU is not set
+# CONFIG_WL1251 is not set
+# CONFIG_WL12XX_MENU is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=y
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_LPC31XX_SERIAL_DMA_SUPPORT is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_OF_PLATFORM is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_XILINX is not set
+CONFIG_SPI_LPC313X=y
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+CONFIG_LPC313X_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+# CONFIG_FB_WMT_GE_ROPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_FB_SSD1289=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+# CONFIG_SND_USB is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_LPC313X_SOC=y
+CONFIG_SND_LPC313X_SOC_I2S=y
+CONFIG_SND_EA3131_SOC_I2S_UDA1380=y
+CONFIG_SND_USE_EA3131=y
+CONFIG_SND_I2C1_CHANNEL_UDA1380=y
+CONFIG_SND_I2S_RX0_MASTER=y
+# CONFIG_SND_I2S_RX1_MASTER is not set
+# CONFIG_SND_I2S_RX0_SLAVE is not set
+# CONFIG_SND_I2S_RX1_SLAVE is not set
+CONFIG_SND_I2S_TX0_MASTER=y
+# CONFIG_SND_I2S_TX1_MASTER is not set
+CONFIG_SND_CODEC_FS256=y
+# CONFIG_SND_CODEC_FS384 is not set
+# CONFIG_SND_CODEC_FS512 is not set
+# CONFIG_SND_CODEC_FS768 is not set
+# CONFIG_SND_CODEC_FS1024 is not set
+# CONFIG_SND_CODEC_NO_FS256_NEEDED is not set
+CONFIG_SND_USE_DMA_LINKLIST=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_UDA1380=y
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_EHSET is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHCI_MV is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+CONFIG_USB_EHCI_LPC=y
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DEBUG=y
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_LPC31XX=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+CONFIG_LEDS_PCA9532=y
+CONFIG_LEDS_PCA9532_GPIO=y
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_TRIGGERS is not set
+
+#
+# LED Triggers
+#
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_IOMMU_SUPPORT=y
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_ROMFS_BACKED_BY_BLOCK=y
+# CONFIG_ROMFS_BACKED_BY_MTD is not set
+# CONFIG_ROMFS_BACKED_BY_BOTH is not set
+CONFIG_ROMFS_ON_BLOCK=y
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=m
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
diff --git a/sound/soc/codecs/uda1380.c b/sound/soc/codecs/uda1380.c
index 773e76f..bddaf4d 100644
--- a/sound/soc/codecs/uda1380.c
+++ b/sound/soc/codecs/uda1380.c
@@ -148,6 +148,7 @@ static void uda1380_sync_cache(struct snd_soc_codec *codec)
 static int uda1380_reset(struct snd_soc_codec *codec)
 {
 	struct uda1380_platform_data *pdata = codec->dev->platform_data;
+	int temp;
 
 	if (gpio_is_valid(pdata->gpio_reset)) {
 		gpio_set_value(pdata->gpio_reset, 1);
@@ -160,7 +161,7 @@ static int uda1380_reset(struct snd_soc_codec *codec)
 		data[1] = 0;
 		data[2] = 0;
 
-		if (codec->hw_write(codec->control_data, data, 3) != 3) {
+		if ((temp = codec->hw_write(codec->control_data, data, 3)) != 3) {
 			dev_err(codec->dev, "%s: failed\n", __func__);
 			return -EIO;
 		}
@@ -728,6 +729,14 @@ static int uda1380_resume(struct snd_soc_codec *codec)
 	return 0;
 }
 
+#ifdef CONFIG_OF
+struct uda1380_platform_data of_pdata = {
+	.gpio_reset = -EINVAL,
+	.gpio_power = -EINVAL,
+	.dac_clk = UDA1380_DAC_CLK_SYSCLK,
+};
+#endif
+
 static int uda1380_probe(struct snd_soc_codec *codec)
 {
 	struct uda1380_platform_data *pdata =codec->dev->platform_data;
@@ -739,8 +748,12 @@ static int uda1380_probe(struct snd_soc_codec *codec)
 	codec->hw_write = (hw_write_t)i2c_master_send;
 	codec->control_data = uda1380->control_data;
 
+#ifdef CONFIG_OF
+	codec->dev->platform_data = pdata = &of_pdata;
+#else
 	if (!pdata)
 		return -EINVAL;
+#endif
 
 	if (gpio_is_valid(pdata->gpio_reset)) {
 		ret = gpio_request_one(pdata->gpio_reset, GPIOF_OUT_INIT_LOW,
@@ -850,10 +863,17 @@ static const struct i2c_device_id uda1380_i2c_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, uda1380_i2c_id);
 
+static const struct of_device_id uda1380_of_match[] = {
+	{ .compatible = "nxp,uda1380", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, uda1380_of_match);
+
 static struct i2c_driver uda1380_i2c_driver = {
 	.driver = {
 		.name =  "uda1380-codec",
 		.owner = THIS_MODULE,
+		.of_match_table = uda1380_of_match,
 	},
 	.probe =    uda1380_i2c_probe,
 	.remove =   __devexit_p(uda1380_i2c_remove),
diff --git a/sound/soc/lpc313x/Kconfig b/sound/soc/lpc313x/Kconfig
index 552dadb..321517a 100644
--- a/sound/soc/lpc313x/Kconfig
+++ b/sound/soc/lpc313x/Kconfig
@@ -17,17 +17,16 @@ config SND_LPC315X_SOC
 config SND_LPC313X_SOC_I2S
         bool
 
-config SND_LPC313X_SOC_I2S_UDA1380
-        bool "SoC Audio for the UDA1380 CODEC using I2S/I2C"
+config SND_EA3131_SOC_I2S_UDA1380
+        bool "EA3131 SoC Audio for the UDA1380 CODEC using I2S/I2C"
         depends on SND_LPC313X_SOC
+        depends on MACH_EA313X
         select I2C_PNX
         select SND_LPC313X_SOC_I2S
         select SND_SOC_UDA1380
         help
           Say Y here if you want to add support for SoC audio on the
-	  LPC313x with the UDA1380 CODEC. This requires an I2S channel
-	  and I2C channel connected to the I2C interface of the
-	  UDA1380 codec.
+	  EA3131 with the UDA1380 CODEC. 
 
 config SND_LPC315X_SOC_I2S_LPC315X_CODEC
 	bool "SoC Audio for the Analog Die CODEC using I2S/I2C in 315X SoC"
@@ -44,7 +43,7 @@ config SND_LPC315X_SOC_I2S_LPC315X_CODEC
 config SND_USE_EA3131
         bool "Enable audio configuration for the EA3131 board"
         depends on SND_LPC313X_SOC
-	select SND_LPC313X_SOC_I2S_UDA1380
+	select SND_EA3131_SOC_I2S_UDA1380
 	select SND_I2C1_CHANNEL_UDA1380
 	select SND_I2S_RX1_MASTER
 	select SND_I2S_TX1_MASTER
@@ -69,7 +68,7 @@ config SND_USE_EA3152
 
 config SND_I2C1_CHANNEL_UDA1380
 	bool "I2C1 channel connected to the UDA1380"
-	depends on SND_LPC313X_SOC_I2S_UDA1380
+	depends on SND_EA3131_SOC_I2S_UDA1380
 	help
 	  Say Y here to use the I2C1 channel to communicate with the
 	  UDA1380 CODEC. Not selecting this option will use I2C0.
diff --git a/sound/soc/lpc313x/Makefile b/sound/soc/lpc313x/Makefile
index 8c42e30..c991f6c 100644
--- a/sound/soc/lpc313x/Makefile
+++ b/sound/soc/lpc313x/Makefile
@@ -7,9 +7,9 @@ obj-$(CONFIG_SND_LPC315X_SOC) += snd-soc-lpc313x.o
 obj-$(CONFIG_SND_LPC313X_SOC_I2S) += snd-soc-lpc313x-i2s.o lpc313x-i2s-clocking.o
 
 # LPC3XXX Machine Support
-snd-soc-lpc313x-uda1380-objs := lpc313x-uda1380.o
+snd-soc-ea3131-uda1380-objs := ea3131-uda1380.o
 
-obj-$(CONFIG_SND_LPC313X_SOC_I2S_UDA1380) += snd-soc-lpc313x-uda1380.o
+obj-$(CONFIG_SND_EA3131_SOC_I2S_UDA1380) += snd-soc-ea3131-uda1380.o
 
 # LPC315X Machine Support
 snd-soc-lpc315x-codec-objs := lpc315x-codec.o
diff --git a/sound/soc/lpc313x/lpc313x-uda1380.c b/sound/soc/lpc313x/ea3131-uda1380.c
similarity index 83%
rename from sound/soc/lpc313x/lpc313x-uda1380.c
rename to sound/soc/lpc313x/ea3131-uda1380.c
index 607d545..0083c41 100644
--- a/sound/soc/lpc313x/lpc313x-uda1380.c
+++ b/sound/soc/lpc313x/ea3131-uda1380.c
@@ -140,10 +140,8 @@ static struct snd_soc_dai_link ea3131_uda1380_dai[] = {
 	{
 		.name = "uda1380",
 		.stream_name = "uda1380",
-		.codec_name	= "uda1380-codec.1-001a",
-		.cpu_dai_name = "lpc313x-i2s.0",
 		.codec_dai_name = "uda1380-hifi",
-		.platform_name	= "lpc313x-audio.0",
+		.platform_name	= "lpc31xx-pcm-audio",
 		.init = ea3131_uda1380_init,
 		.ops = &ea3131_uda1380_ops,
 	},
@@ -161,54 +159,55 @@ static struct uda1380_platform_data uda1380_info = {
 	.gpio_reset = -1,
 };
 
-static struct i2c_board_info i2c_board_info[] = {
-	{
-		I2C_BOARD_INFO("uda1380", 0x1A),
-		.platform_data = &uda1380_info,
-	},
-};
-
 static struct platform_device *ea3131_snd_device;
 
-static int __devinit ea3131_asoc_probe(struct platform_device *pd)
+static int __devinit ea3131_asoc_probe(struct platform_device *pdev)
 {
 	struct platform_device *snd_dev;
 	int ret = 0;
 	struct i2c_adapter *adapter;
-	struct i2c_client *client;
 
 	/*
 	 * Enable CODEC clock first or I2C will fail to the CODEC
 	 */
 	lpc313x_main_clk_rate(48000);
 
-#if defined (CONFIG_SND_I2C1_CHANNEL_UDA1380)
-	adapter = i2c_get_adapter(1);
-#else
-	adapter = i2c_get_adapter(0);
-#endif
-	if (!adapter)
-		return -ENODEV;
-	client = i2c_new_device(adapter, i2c_board_info);
-	i2c_put_adapter(adapter);
-	if (!client)
-		return -ENODEV;
-
 	snd_dev = platform_device_alloc("soc-audio", -1);
 	if (!snd_dev) {
-		dev_err(&pd->dev, "failed to alloc soc-audio devicec\n");
+		dev_err(&pdev->dev, "failed to alloc soc-audio device\n");
 		return -ENOMEM;
 	}
 
+	ea3131_uda1380_dai[0].codec_of_node = of_parse_phandle(
+			pdev->dev.of_node, "audio-codec", 0);
+	if (!ea3131_uda1380_dai[0].codec_of_node) {
+		dev_err(&pdev->dev,
+			"Property 'audio-codec' missing or invalid\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ea3131_uda1380_dai[0].cpu_dai_of_node = of_parse_phandle(
+			pdev->dev.of_node, "i2s-controller", 0);
+	if (!ea3131_uda1380_dai[0].cpu_dai_of_node) {
+		dev_err(&pdev->dev,
+			"Property 'i2s-controller' missing or invalid\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
 	platform_set_drvdata(snd_dev, &snd_soc_machine_ea3131);
 
 	ret = platform_device_add(snd_dev);
 	if (ret) {
-		dev_err(&pd->dev, "failed to add soc-audio dev\n");
+		dev_err(&pdev->dev, "failed to add soc-audio dev\n");
 		return -ENODEV;
 	}
 
-	platform_set_drvdata(pd, snd_dev);
+	platform_set_drvdata(pdev, snd_dev);
+	return 0;
+
+err:
 	return ret;
 }
 
@@ -220,11 +219,22 @@ static int __devexit ea3131_asoc_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id ea3131_asoc_of_match[] = {
+	{ .compatible = "ea,ea3131-uda1380" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ea3131_asoc_of_match);
+#endif
+
 static struct platform_driver ea3131_asoc_platdrv = {
 	.driver	= {
 		.owner	= THIS_MODULE,
-		.name	= "lpc313x-uda1380",
+		.name	= "ea3131-uda1380",
 		//.pm	= ea3131_asoc_pm,
+#ifdef CONFIG_OF
+		.of_match_table = ea3131_asoc_of_match,
+#endif
 	},
 	.probe	= ea3131_asoc_probe,
 	.remove	= __devexit_p(ea3131_asoc_remove),
@@ -244,7 +254,7 @@ module_init(ea3131_asoc_modinit);
 module_exit(ea3131_asoc_modexit);
 
 MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
-MODULE_DESCRIPTION("ASoC machine driver for LPC313X/UDA1380");
+MODULE_DESCRIPTION("ASoC machine driver for EA3131/UDA1380");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:lpc313x-uda1380");
+MODULE_ALIAS("platform:ea3131-uda1380");
 
diff --git a/sound/soc/lpc313x/lpc313x-i2s.c b/sound/soc/lpc313x/lpc313x-i2s.c
index bdf6b45..d255fa7 100644
--- a/sound/soc/lpc313x/lpc313x-i2s.c
+++ b/sound/soc/lpc313x/lpc313x-i2s.c
@@ -407,12 +407,23 @@ static __devexit int lpc313x_i2s_dev_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id lpc313x_i2s_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-i2s" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_i2s_of_match);
+#endif
+
 static struct platform_driver lpc313x_i2s_driver = {
 	.probe  = lpc313x_i2s_dev_probe,
 	.remove = lpc313x_i2s_dev_remove,
 	.driver = {
 		.name = I2S_NAME,
 		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = lpc313x_i2s_of_match,
+#endif
 	},
 };
 
diff --git a/sound/soc/lpc313x/lpc313x-pcm.c b/sound/soc/lpc313x/lpc313x-pcm.c
index 26bdb28..5af9b97 100644
--- a/sound/soc/lpc313x/lpc313x-pcm.c
+++ b/sound/soc/lpc313x/lpc313x-pcm.c
@@ -33,7 +33,7 @@
 #include <mach/dma.h>
 #include "lpc313x-pcm.h"
 
-#define SND_NAME "lpc313x-audio"
+#define SND_NAME "lpc31xx-pcm-audio"
 static u64 lpc313x_pcm_dmamask = DMA_BIT_MASK(32);
 
 #if defined (CONFIG_SND_USE_DMA_LINKLIST)
