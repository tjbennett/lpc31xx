Bottom: 4c23abd58bfb863c9140f2ef357288bce106481e
Top:    819e6d417c84d217c6ebeab1f0e9fa90f6b2bec1
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-21 23:06:31 -0400

intr domain irq


---

diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index d257d47..88553e2 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -90,7 +90,8 @@ static struct plat_serial8250_port platform_serial_ports[] = {
 	{
 		.membase = (void *)io_p2v(UART_PHYS),
 		.mapbase = (unsigned long)UART_PHYS,
-		.irq = IRQ_UART,
+		//.irq = IRQ_UART,
+		.irq = 13,
 		.uartclk = XTAL_CLOCK,
 		.regshift = 2,
 		.iotype = UPIO_MEM,
@@ -266,7 +267,8 @@ static int __init lpc31xx_init_console(void)
 
 	up.membase = (char *) io_p2v(UART_PHYS);
 	up.mapbase = (unsigned long)UART_PHYS,
-	up.irq = IRQ_UART;
+//	up.irq = IRQ_UART;
+	up.irq = 13;
 	up.uartclk = XTAL_CLOCK;
 	/* check what FDR bootloader is using */
 	mul = (UART_FDR_REG >> 4) & 0xF;
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
index 8de96b1..8727e9f 100644
--- a/arch/arm/mach-lpc31xx/irq.c
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -26,6 +26,7 @@
 #include <linux/timer.h>
 #include <linux/of_irq.h>
 #include <linux/irqdomain.h>
+#include <linux/of_address.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -37,28 +38,28 @@
 #define EVT_GET_BANK(evt)	(((evt) >> 5) & 0x3)
 #define EVT_arm926_nirq		0x6C
 
-extern void __init lpc31xx_init_evtr(void);
+static struct irq_domain *intc_domain;
 
 static void intc_mask_irq(struct irq_data *data)
 {
-	INTC_REQ_REG(data->irq) = INTC_REQ_WE_ENABLE;
+	INTC_REQ_REG(data->hwirq) = INTC_REQ_WE_ENABLE;
 }
 
 static void intc_unmask_irq(struct irq_data *data)
 {
-	INTC_REQ_REG(data->irq) = INTC_REQ_ENABLE | INTC_REQ_WE_ENABLE;
+	INTC_REQ_REG(data->hwirq) = INTC_REQ_ENABLE | INTC_REQ_WE_ENABLE;
 }
 
 static int intc_set_wake(struct irq_data *data, unsigned int on)
 {
-	static u32 wake_ints = 0;
+	static uint32_t wake_ints = 0;
 
 	if (on)
 		/* save the irqs which wake */
-		wake_ints |= _BIT(data->irq);
+		wake_ints |= _BIT(data->hwirq);
 	else
 		/* clear the irqs which don't wake */
-		wake_ints &= ~_BIT(data->irq);
+		wake_ints &= ~_BIT(data->hwirq);
 
 	/* Note: the clocks to corresponding blocks shouldn't be suspended
 	 * by individual drivers for this logic to work.
@@ -91,11 +92,36 @@ static const struct of_device_id intc_of_match[] __initconst = {
 	{},
 };
 
-void __init lpc31xx_init_irq(void)
+static int intc_irq_map(struct irq_domain *h, unsigned int virq, irq_hw_number_t hw)
 {
-	unsigned int irq;
+	/* Set the initial control values */
+	INTC_REQ_REG(hw) = INTC_REQ_WE_ENABLE;
+
+	/* Initialize as high-active, Disable the interrupt,
+	* Set target to IRQ , Set priority level to 1 (= lowest) for
+	* all the interrupt lines */
+	INTC_REQ_REG(hw) = INTC_REQ_WE_ACT_LOW |
+		INTC_REQ_WE_ENABLE |
+		INTC_REQ_TARGET_IRQ |
+		INTC_REQ_PRIO_LVL(1) |
+		INTC_REQ_WE_PRIO_LVL;
+
+	irq_set_chip_and_handler(virq, &lpc31xx_internal_chip,
+				 handle_level_irq);
+	set_irq_flags(virq, IRQF_VALID);
+
+	printk("intc hw=%ld virq=%d\n", hw, virq);
+	return 0;
+}
 
-	irq_domain_generate_simple(intc_of_match, 0x60000000, 0);
+static struct irq_domain_ops intc_ops = {
+	.map	= intc_irq_map,
+	.xlate	= irq_domain_xlate_onecell,
+};
+
+void __init lpc31xx_init_irq(void)
+{
+	struct device_node *node;
 
 	/* enable clock to interrupt controller */
 	cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, 1);
@@ -111,30 +137,13 @@ void __init lpc31xx_init_irq(void)
 	INTC_IRQ_PRI_MASK = 0xFF;
 	INTC_FIQ_PRI_MASK = 0xFF;
 
-	/* Clear and disable all interrupts. Start from index 1 since 0 is unused.*/
-	for (irq = 1; irq < NR_IRQ_CPU; irq++) {
-		/* Set the initial control values */
-		INTC_REQ_REG(irq) = INTC_REQ_WE_ENABLE;
-
-		/* Initialize as high-active, Disable the interrupt,
-		* Set target to IRQ , Set priority level to 1 (= lowest) for
-		* all the interrupt lines */
-		INTC_REQ_REG(irq) = INTC_REQ_WE_ACT_LOW |
-			INTC_REQ_WE_ENABLE |
-			INTC_REQ_TARGET_IRQ |
-			INTC_REQ_PRIO_LVL(1) |
-			INTC_REQ_WE_PRIO_LVL;
-
-		irq_set_chip_and_handler(irq, &lpc31xx_internal_chip,
-					 handle_level_irq);
-		set_irq_flags(irq, IRQF_VALID);
-	}
+	node = of_find_matching_node_by_address(NULL, intc_of_match, INTC_PHYS);
+	intc_domain = irq_domain_add_linear(node, NR_IRQ_CPU, &intc_ops, NULL);
 
 	/* Set the priority threshold to 0, i.e. don't mask any interrupt */
 	/* on the basis of priority level, for both targets (IRQ/FIQ)    */
 	INTC_IRQ_PRI_MASK = 0;
 	INTC_FIQ_PRI_MASK = 0;
-
 }
